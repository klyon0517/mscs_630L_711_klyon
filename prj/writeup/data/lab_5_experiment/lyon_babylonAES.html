<!--  BabylonAES

      * Software: MSCS 630L Semester Project
      * Filename: lyon_babylonAES.php
      * Author: Kerry Lyon
      * Created: May 8, 2022

      * Final full animation of 128 bit AES encryption.

-->



<!DOCTYPE html>
<html  xmlns="http://www.w3.org/1999/xhtml">
	<head>
  
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<meta name="description" content="BabylonAES" />
    <meta name="keywords" content="aes, encryption, animation, babylonjs, marist, college, cryptography, algorithms" />
    <meta name="author" content="Kerry Lyon" />
		
		<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
		<title>BabylonAES</title>
		
    <style>
    
      html, body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }
      
    </style>
        
    <!-- Babylyon.js -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        
  </head>
  <body>
    
    <canvas id="renderCanvas"></canvas>
       
    <script>
    
      const canvas = document.getElementById("renderCanvas");
      const engine = new BABYLON.Engine(canvas, true);

      const createScene =  () => {
        
        // initial setup
        const scene = new BABYLON.Scene(engine);
        // Background color
        scene.clearColor = new BABYLON.Color3.FromHexString('#b3e6ff');
        
        // Camera
        const camera = new BABYLON.ArcRotateCamera("camera", 0, Math.PI / 2, 5, new BABYLON.Vector3(0, -5, 0), scene);
        camera.attachControl(canvas, true);
        
        // Light
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
        light.groundColor = new BABYLON.Color3(1, 1, 1);
        
        // ------------------------ plaintext ------------------------- //
        
        // Sample Input 1
        const key = "5468617473206D79204B756E67204675";
        const plaintext = "54776F204F6E65204E696E652054776F";
        // ciphertext = 29C3505F571420F6402299B31A02D73A;
                
        console.log("key: " + key);
        console.log("plaintext: " + plaintext);
                
        const RCon = ["8D", "01", "02", "04", "08", "10", "20", "40", "80", "1B", "36"];
        const SBox = [
          ["63", "7C", "77", "7B", "F2", "6B", "6F", "C5", "30", "01", "67", "2B", "FE", "D7", "AB", "76"],
          ["CA", "82", "C9", "7D", "FA", "59", "47", "F0", "AD", "D4", "A2", "AF", "9C", "A4", "72", "C0"],
          ["B7", "FD", "93", "26", "36", "3F", "F7", "CC", "34", "A5", "E5", "F1", "71", "D8", "31", "15"],
          ["04", "C7", "23", "C3", "18", "96", "05", "9A", "07", "12", "80", "E2", "EB", "27", "B2", "75"],
          ["09", "83", "2C", "1A", "1B", "6E", "5A", "A0", "52", "3B", "D6", "B3", "29", "E3", "2F", "84"],
          ["53", "D1", "00", "ED", "20", "FC", "B1", "5B", "6A", "CB", "BE", "39", "4A", "4C", "58", "CF"],
          ["D0", "EF", "AA", "FB", "43", "4D", "33", "85", "45", "F9", "02", "7F", "50", "3C", "9F", "A8"],
          ["51", "A3", "40", "8F", "92", "9D", "38", "F5", "BC", "B6", "DA", "21", "10", "FF", "F3", "D2"],
          ["CD", "0C", "13", "EC", "5F", "97", "44", "17", "C4", "A7", "7E", "3D", "64", "5D", "19", "73"],
          ["60", "81", "4F", "DC", "22", "2A", "90", "88", "46", "EE", "B8", "14", "DE", "5E", "0B", "DB"],
          ["E0", "32", "3A", "0A", "49", "06", "24", "5C", "C2", "D3", "AC", "62", "91", "95", "E4", "79"],
          ["E7", "C8", "37", "6D", "8D", "D5", "4E", "A9", "6C", "56", "F4", "EA", "65", "7A", "AE", "08"],
          ["BA", "78", "25", "2E", "1C", "A6", "B4", "C6", "E8", "DD", "74", "1F", "4B", "BD", "8B", "8A"],
          ["70", "3E", "B5", "66", "48", "03", "F6", "0E", "61", "35", "57", "B9", "86", "C1", "1D", "9E"],
          ["E1", "F8", "98", "11", "69", "D9", "8E", "94", "9B", "1E", "87", "E9", "CE", "55", "28", "DF"],
          ["8C", "A1", "89", "0D", "BF", "E6", "42", "68", "41", "99", "2D", "0F", "B0", "54", "BB", "16"]
        ];
        
        
        const SBoxBackground = [
          ["63", "7C", "77", "7B", "F2", "6B", "6F", "C5", "30", "01", "67", "2B", "FE", "D7", "AB", "76"],
          ["CA", "82", "C9", "7D", "FA", "59", "47", "F0", "AD", "D4", "A2", "AF", "9C", "A4", "72", "C0"],
          ["B7", "FD", "93", "26", "36", "3F", "F7", "CC", "34", "A5", "E5", "F1", "71", "D8", "31", "15"],
          ["04", "C7", "23", "C3", "18", "96", "05", "9A", "07", "12", "80", "E2", "EB", "27", "B2", "75"],
          ["09", "83", "2C", "1A", "1B", "6E", "5A", "A0", "52", "3B", "D6", "B3", "29", "E3", "2F", "84"],
          ["53", "D1", "00", "ED", "20", "FC", "B1", "5B", "6A", "CB", "BE", "39", "4A", "4C", "58", "CF"],
          ["D0", "EF", "AA", "FB", "43", "4D", "33", "85", "45", "F9", "02", "7F", "50", "3C", "9F", "A8"],
          ["51", "A3", "40", "8F", "92", "9D", "38", "F5", "BC", "B6", "DA", "21", "10", "FF", "F3", "D2"],
          ["CD", "0C", "13", "EC", "5F", "97", "44", "17", "C4", "A7", "7E", "3D", "64", "5D", "19", "73"],
          ["60", "81", "4F", "DC", "22", "2A", "90", "88", "46", "EE", "B8", "14", "DE", "5E", "0B", "DB"],
          ["E0", "32", "3A", "0A", "49", "06", "24", "5C", "C2", "D3", "AC", "62", "91", "95", "E4", "79"],
          ["E7", "C8", "37", "6D", "8D", "D5", "4E", "A9", "6C", "56", "F4", "EA", "65", "7A", "AE", "08"],
          ["BA", "78", "25", "2E", "1C", "A6", "B4", "C6", "E8", "DD", "74", "1F", "4B", "BD", "8B", "8A"],
          ["70", "3E", "B5", "66", "48", "03", "F6", "0E", "61", "35", "57", "B9", "86", "C1", "1D", "9E"],
          ["E1", "F8", "98", "11", "69", "D9", "8E", "94", "9B", "1E", "87", "E9", "CE", "55", "28", "DF"],
          ["8C", "A1", "89", "0D", "BF", "E6", "42", "68", "41", "99", "2D", "0F", "B0", "54", "BB", "16"]
        ];
        
        var i4 = 0;
        var i4_2 = 0;
        var iSBox = 0;
        var iSBox2 = 0;
        var iRCon = 0;
        var iXOR = 0;        
        var sXOR = 0;       
        var sXOR2 = 0;
        var iNibble = 0;
        var iShift = 0;
        var iMix = 0;
                
        const ciphertext = AES(plaintext, key);
        console.log("ciphertext: " + ciphertext);
                
        // Width / Height
        var DTWidth;
        var DTHeight;
                
        const frameRate = 10;
        var letter;
        
        // Spawn normal plane
        function normalPlane(str, heightFactor, posx, posy, posz, fontColor, color, alpha, useAlpha, roty) {
          
          //Set font
          var font_size = 48;
          var font = "bold " + font_size + "px Arial";
        
          //Set height for plane
          var planeHeight = heightFactor;
          
          //Set height for dynamic texture
          var DTHeight = 1.5 * font_size; //or set as wished
          
          //Calcultae ratio
          var ratio = planeHeight/DTHeight;
          
          //Use a temporay dynamic texture to calculate the length of the text on the dynamic texture canvas
          var temp = new BABYLON.DynamicTexture("DynamicTexture", 64, scene);
          var tmpctx = temp.getContext();
          tmpctx.font = font;
          var DTWidth = tmpctx.measureText(str).width + 8;
          
          //Calculate width the plane has to be 
          var planeWidth = DTWidth * ratio;
          
          // Dynamic texture setup
          var planeDynTex = new BABYLON.DynamicTexture("PlaneDynTex", {width:DTWidth, height:DTHeight}, scene);
          var ctx = planeDynTex.getContext();
          
          var plainMat = new BABYLON.StandardMaterial("PlainMat", scene);
          plainMat.diffuseTexture = planeDynTex;
          plainMat.diffuseTexture.hasAlpha = alpha;
          plainMat.useAlphaFromDiffuseTexture = useAlpha;
          
          var plane = BABYLON.MeshBuilder.CreatePlane("plane", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
          plane.material = plainMat;
          planeDynTex.drawText(str, null, null, font, fontColor, color, true);
                       
          plainMat.onBindObservable.add(() => {
            
            engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
            
          });

          plane.position = new BABYLON.Vector3(posx, posy, posz);
          plane.rotation.y = roty;
                      
        }
        
        // key
        normalPlane("Key", 2, -30, 0, 0, "blue", "transparent", "true", "true", -Math.PI / 2);
        normalPlane(key, 2, -30, -2.25, 0, "blue", "white", "false", "false", -Math.PI / 2);
        
        // plaintext
        normalPlane("Plaintext", 2, -30, -7.25, 0, "blue", "transparent",  "true", "true", -Math.PI / 2);
        normalPlane(plaintext, 2, -30, -9.5, 0, "blue", "white", "false", "false", -Math.PI / 2);
        
        // Spawn array plane
        function arrayPlane(matrix, planeHeight, planeWidth, posx, posy, posz, xFactor, zFactor, fontColor, color, alpha, useAlpha, roty) {
          
          var DTWidth = planeWidth * 128;
          var DTHeight = planeHeight * 128;
          
          for (var x = 0; x < matrix.length; x++) {
          
            var letter = matrix[x];
                    
            var arrayDynTex = new BABYLON.DynamicTexture("arrayDynTex", {width:DTWidth, height:DTHeight}, scene);
            var ctx = arrayDynTex.getContext();
            
            // Font sized to fit the plane
            var font_type = "Arial";
            var size = 12;
            var text = "8D";
            ctx.font = size + "px " + font_type;
            var textWidth = ctx.measureText(text).width;
            
            var ratio = textWidth/size;
            
            var font_size = Math.floor(DTWidth / (ratio * 1));
            var font = font_size + "px " + font_type;
            
            var arrayMat = new BABYLON.StandardMaterial("arrayMat", scene);                    
            arrayMat.diffuseTexture = arrayDynTex;
            arrayMat.diffuseTexture.hasAlpha = alpha;
            arrayMat.useAlphaFromDiffuseTexture = useAlpha;
            
            var arrayPlane = BABYLON.MeshBuilder.CreatePlane("arrayPlane", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            arrayPlane.material = arrayMat;
            arrayDynTex.drawText(letter, null, null, font, fontColor, color, true);
            
            arrayMat.onBindObservable.add(() => {
              
              engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
              
            });
            
            arrayPlane.position = new BABYLON.Vector3((x * xFactor) + posx, posy, (x * zFactor) + posz);
            arrayPlane.rotation.y = roty;
                      
          }

        }        
        
        // Spawn matrix plane
        function matrixPlane(matrix, planeHeight, planeWidth, posx, posy, posz, xFactor, yFactor, zFactor, fontColor, color, alpha, useAlpha, roty) {
          
          var DTWidth = planeWidth * 128;
          var DTHeight = planeHeight * 128;
          
          for (var x = 0; x < matrix.length; x++) {
          
            for (var y = 0; y < matrix[x].length; y++) {
              
              letter = matrix[y][x];
                      
              var matrixDynTex = new BABYLON.DynamicTexture("matrixDynTex", {width:DTWidth, height:DTHeight}, scene);
              var ctx = matrixDynTex.getContext();
              
              // Font sized to fit the plane
              var font_type = "Arial";
              var size = 12;
              var text = "8D";
              ctx.font = size + "px " + font_type;
              var textWidth = ctx.measureText(text).width;
              
              var ratio = textWidth/size;
              
              var font_size = Math.floor(DTWidth / (ratio * 1));
              var font = font_size + "px " + font_type;
              
              var matrixMat = new BABYLON.StandardMaterial("matrixMat", scene);                    
              matrixMat.diffuseTexture = matrixDynTex;
              matrixMat.diffuseTexture.hasAlpha = alpha;
              matrixMat.useAlphaFromDiffuseTexture = useAlpha;
              
              var matrixPlane = BABYLON.MeshBuilder.CreatePlane("matrixPlane", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
              matrixPlane.material = matrixMat;
              matrixDynTex.drawText(letter, null, null, font, fontColor, color, true);
              
              matrixMat.onBindObservable.add(() => {
                
                engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
                
              });
              
              matrixPlane.position = new BABYLON.Vector3((x * xFactor) + posx, (y * yFactor) + posy, (x * zFactor) + posz);
              matrixPlane.rotation.y = roty;
                            
            }
            
          }
          
        }
        
        
        // RCon
        normalPlane("RCon", 2, -20, 0, 30, "blue", "transparent",  "true", "true", 0);
        arrayPlane(RCon, 2, 2, -20, -2.25, 30, 2.25, 0, "blue", "white", "false", "false", 0);
        // Rounds        
        normalPlane("Round Keys", 2, 10, 0, 30, "blue", "transparent",  "true", "true", 0);
        
        // SBoxBackground
        normalPlane("SBox", 2.5, 40, 0, -75, "blue", "transparent",  "true", "true", Math.PI);
        matrixPlane(SBoxBackground, 5, 5, 40, -5, -75, -5.55, -5.55, 0, "blue", "white", "false", "false", Math.PI);
                
        // ciphertext        
        normalPlane("Ciphertext", 2, -30, -14.50, 0, "blue", "transparent",  "true", "true", -Math.PI / 2);
        
        // Spawn ciphertext plane
        function ciphertextPlane(str, heightFactor, posx, posy, posz, fontColor, color, alpha, useAlpha, roty) {
          
          //Set font
          var font_size = 48;
          var font = "bold " + font_size + "px Arial";
        
          //Set height for plane
          var planeHeight = heightFactor;
          
          //Set height for dynamic texture
          var DTHeight = 1.5 * font_size; //or set as wished
          
          //Calcultae ratio
          var ratio = planeHeight/DTHeight;
          
          //Use a temporay dynamic texture to calculate the length of the text on the dynamic texture canvas
          var temp = new BABYLON.DynamicTexture("DynamicTexture", 64, scene);
          var tmpctx = temp.getContext();
          tmpctx.font = font;
          var DTWidth = tmpctx.measureText(str).width + 8;
          
          //Calculate width the plane has to be 
          var planeWidth = DTWidth * ratio;
              
          // Dynamic texture setup
          var planeDynTex = new BABYLON.DynamicTexture("PlaneDynTex", {width:DTWidth, height:DTHeight}, scene);
          var ctx = planeDynTex.getContext();
          
          var plainMat = new BABYLON.StandardMaterial("PlainMat", scene);
          plainMat.diffuseTexture = planeDynTex;
          plainMat.diffuseTexture.hasAlpha = alpha;
          plainMat.useAlphaFromDiffuseTexture = useAlpha;
          
          var plane = BABYLON.MeshBuilder.CreatePlane("plane", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
          plane.material = plainMat;
          planeDynTex.drawText(str, null, null, font, fontColor, color, true);
          
          plainMat.onBindObservable.add(() => {
            
            engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
            
          });

          plane.position = new BABYLON.Vector3(posx, posy, posz);
          plane.rotation.y = roty;
                        
          const frameRate = 10;
        
          // Animation
          var visibleTog = new BABYLON.Animation("visibleTog", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
            
          var visFrames = [];
          
          visFrames.push({
            frame: 0,
            value: 0,
          });
          
          visFrames.push({
            frame: 826 * frameRate / 2,
            value: 0,
          });
          
          visFrames.push({
            frame: 826 * frameRate / 2,
            value: 1,
          });

          visibleTog.setKeys(visFrames);
          
          scene.beginDirectAnimation(plane, [visibleTog], 0, 827 * frameRate / 2, false);
                                                 
        }
        
        ciphertextPlane(ciphertext, 2, -30, -16.75, 0, "blue", "yellow", "false", "false", -Math.PI / 2);
        
        
        /*
         * aesRoundKeys
         *
         * This method produces the 11 round keys.
         *
         * Parameters:
         *  String KeyHex: System key (16-hex string representation)
         *
         * Return value: 11-row string array representation of all the round keys
         */
        function aesRoundKeys(KeyHex) {
                        
          var row2 = 4, col2 = 4; 
          var Ke = Array(row2).fill().map(() => Array(col2));
          Ke = toMatrix(KeyHex);
          
          const frameRate = 10;
                   
          //Set font
          var font_sizeKe = 48;
          var fontKe = "bold " + font_sizeKe + "px Arial";
          
          var planeHeightKe = 2;
                  
          //Set height for dynamic texture
          var DTHeightKe = 1.5 * font_sizeKe; //or set as wished
          
          //Calcultae ratio
          var ratio = planeHeightKe/DTHeightKe;
          
          //Use a temporay dynamic texture to calculate the length of the text on the dynamic texture canvas
          var temp = new BABYLON.DynamicTexture("DynamicTexture", 64, scene);
          var tmpctx = temp.getContext();
          tmpctx.font = fontKe;
          var DTWidthKe = tmpctx.measureText("Ke = toMatix(KeyHex)").width + 8;
          
          //Calculate width the plane has to be 
          var planeWidthKe = DTWidthKe * ratio;
          
          // Dynamic texture setup
          var kePlaneDynTex = new BABYLON.DynamicTexture("kePlaneDynTex", {width:DTWidthKe, height:DTHeightKe}, scene);
          var ctx = kePlaneDynTex.getContext();
          
          var kePlainMat = new BABYLON.StandardMaterial("kePlainMat", scene);
          kePlainMat.diffuseTexture = kePlaneDynTex;
          kePlainMat.diffuseTexture.hasAlpha = true;
          kePlainMat.useAlphaFromDiffuseTexture = true;
          
          var kePlane = BABYLON.MeshBuilder.CreatePlane("kePlane", {height: planeHeightKe, width: planeWidthKe, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
          kePlane.material = kePlainMat;
          kePlaneDynTex.drawText("Ke = toMatix(KeyHex)", null, null, fontKe, "blue", "transparent", true);
                       
          kePlainMat.onBindObservable.add(() => {
            
            engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
            
          });

          kePlane.position = new BABYLON.Vector3(-15, -6, 30);
          kePlane.rotation.y = 0;
          
          // Animation
          var visibleTogKe = new BABYLON.Animation("visibleTogKe", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
          
          var visFramesKe = [];
      
          visFramesKe.push({
            frame: 0,
            value: 0,
          });
          
          visFramesKe.push({
            frame: 4 * frameRate / 2,
            value: 0,
          });

          visFramesKe.push({
            frame: 4 * frameRate / 2,
            value: 1,
          });

          visFramesKe.push({
            frame: 8 * frameRate / 2,
            value: 1,
          });

          visFramesKe.push({
            frame: 8 * frameRate / 2,
            value: 0,
          });

          visibleTogKe.setKeys(visFramesKe);
          
          scene.beginDirectAnimation(kePlane, [visibleTogKe], 0, 9 * frameRate / 2, false);
          
          //  Ke Matrix
          var planeWidth = 2;
          var planeHeight = 2;
          
          var DTWidth = planeWidth * 128;
          var DTHeight = planeHeight * 128;
          
          for (var x1 = 0; x1 < Ke.length; x1++) {
          
            for (var y1 = 0; y1 < Ke[x1].length; y1++) {
              
              var dat1 = Ke[y1][x1];
                      
              var toMatrixDynTex = new BABYLON.DynamicTexture("toMatrixDynTex", {width:DTWidth, height:DTHeight}, scene);
              var ctx = toMatrixDynTex.getContext();
              
              // Font sized to fit the plane
              var font_type = "Arial";
              var size = 12;
              var text = "8D";
              ctx.font = size + "px " + font_type;
              var textWidth = ctx.measureText(text).width;
              
              var ratio = textWidth/size;
              
              var font_size = Math.floor(DTWidth / (ratio * 1));
              var font = font_size + "px " + font_type;
              
              var toMatrixMat = new BABYLON.StandardMaterial("toMatrixMat", scene);                    
              toMatrixMat.diffuseTexture = toMatrixDynTex;
              
              var toMatrixPlane = BABYLON.MeshBuilder.CreatePlane("toMatrixPlane", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
              toMatrixPlane.material = toMatrixMat;
              toMatrixDynTex.drawText(dat1, null, null, font, "blue", "white", true);
                                          
              toMatrixPlane.position = new BABYLON.Vector3((x1 * 2.25) + -20, (y1 * -2.25) + -9, 30);
              toMatrixPlane.rotation.y = 0;
              
              // Animation
              var visibleTog1 = new BABYLON.Animation("visibleTog1", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
              
              var visFrames1 = [];
          
              visFrames1.push({
                frame: 0,
                value: 0,
              });
              
              visFrames1.push({
                frame: 4 * frameRate / 2,
                value: 0,
              });

              visFrames1.push({
                frame: 4 * frameRate / 2,
                value: 1,
              });

              visFrames1.push({
                frame: 8 * frameRate / 2,
                value: 1,
              });

              visFrames1.push({
                frame: 8 * frameRate / 2,
                value: 0,
              });

              visibleTog1.setKeys(visFrames1);
              
              scene.beginDirectAnimation(toMatrixPlane, [visibleTog1], 0, 9 * frameRate / 2, false);
                            
            }
            
          }

          var row3 = 44, col = 4; 
          var W = Array(row3).fill().map(() => Array(col));

          // Make AES key to be the first four columns of W.
          for (var i = 0; i < 4; i++) {
            
            W[i] = Ke[i];
              
          }
          
          for (var j = 4; j < 44; j++) {
            
            if (j % 4 != 0) {
                          
              // If column index j is NOT a multiple of 4, XOR the fourth past and last column.
              for(var i = 0; i < 4; i++) {
                              
                var num = W[j-1][i];
                
                if (num.length < 2) {
                  
                  var wchar = "0" + W[j-1][i];
                  
                } else {
                  
                  var wchar = W[j-1][i];
                  
                }
                
                W[j][i] = XorHex(W[j-4][i],wchar);
                  
              }
              
              i4++;
                
            } else {
              
              // If column index j is a multiple of 4, starting a new round.
              var rcon = aesRcon(j/4);
              
              // 1
              var num2 = W[j-1][1];
              
              if (num2.length < 2) {
                
                var wchar2 = "0" + W[j-1][1];
                
              } else {
                
                var wchar2 = W[j-1][1];
                
              }
              
              // 2
              var num3 = W[j-1][2];
              
              if (num3.length < 2) {
                
                var wchar3 = "0" + W[j-1][2];
                
              } else {
                
                var wchar3 = W[j-1][2];
                
              }
              
              // 3
              var num4 = W[j-1][3];
              
              if (num4.length < 2) {
                
                var wchar4 = "0" + W[j-1][3];
                
              } else {
                
                var wchar4 = W[j-1][3];
                
              }
              
              // 4
              var num5 = W[j-1][0];
              
              if (num5.length < 2) {
                
                var wchar5 = "0" + W[j-1][0];
                
              } else {
                
                var wchar5 = W[j-1][0];
                
              }
              
              var Wnew = [];
              Wnew = [          
                XorHex(rcon, aesSBox(wchar2)),
                aesSBox(wchar3),
                aesSBox(wchar4),
                aesSBox(wchar5)];
                                
              for (var i = 0; i < 4; i++) {
                
                var num6 = W[j-4][i];
                
                if (num6.length < 2) {
                  
                  var wchar6 = "0" + W[j-4][i];
                  
                } else {
                  
                  var wchar6 = W[j-4][i];
                  
                }
                
                W[j][i] = XorHex(wchar6, Wnew[i]);
                  
              }
              
              i4++;
                
            }
              
          }
          
          // Every round key is composed of 4 successive readings of the columns W.          
          var outKeysSize = 11; 
          var outKeys = Array(outKeysSize).fill();
          
          for (var i = 0; i < 11; i++) {
            
            var row = "";
            
            for(var j = 0; j < 4; j++) {
              
              row += W[4 * i + j];
                            
            }
            
            outKeys[i] = row.replaceAll(',', '');
            
            //Set font
            var font_size = 48;
            var font = "bold " + font_size + "px Arial";
          
            //Set height for plane
            var planeHeight = 2;
            
            //Set height for dynamic texture
            var DTHeight = 1.5 * font_size; //or set as wished
            
            //Calcultae ratio
            var ratio = planeHeight/DTHeight;
            
            //Use a temporay dynamic texture to calculate the length of the text on the dynamic texture canvas
            var temp = new BABYLON.DynamicTexture("DynamicTexture", 64, scene);
            var tmpctx = temp.getContext();
            tmpctx.font = font;
            var DTWidth2 = tmpctx.measureText(outKeys[i]).width + 8;
            
            //Calculate width the plane has to be 
            var planeWidth = DTWidth2 * ratio;
                        
            var outKeyDynTex = new BABYLON.DynamicTexture("outKeyDynTex", {width:DTWidth2, height:DTHeight}, scene);
            var outKeyDynTex2 = new BABYLON.DynamicTexture("outKeyDynTex2", {width:DTWidth2, height:DTHeight}, scene);
            
            var outKeyMat = new BABYLON.StandardMaterial("outKeyMat", scene);                    
            outKeyMat.diffuseTexture = outKeyDynTex;
            var outKeyMat2 = new BABYLON.StandardMaterial("outKeyMat2", scene);                    
            outKeyMat2.diffuseTexture = outKeyDynTex2;
            
            var outKeyPlane = BABYLON.MeshBuilder.CreatePlane("outKeyPlane", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            outKeyPlane.material = outKeyMat;
            outKeyDynTex.drawText(outKeys[i], null, null, font, "blue", "yellow", true);
            var outKeyPlane2 = BABYLON.MeshBuilder.CreatePlane("outKeyPlane2", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            outKeyPlane2.material = outKeyMat2;
            outKeyDynTex2.drawText(outKeys[i], null, null, font, "blue", "grey", true);
            
            // normalPlane("Rounds", 2, 10, 0, 30, "blue", "transparent",  "true", "true", 0);
            outKeyPlane.position = new BABYLON.Vector3(20, (i * -2.5) + -2.25, 30);
            outKeyPlane.rotation.y = 0;
            outKeyPlane2.position = new BABYLON.Vector3(20, (i * -2.5) + -2.25, 30);
            outKeyPlane2.rotation.y = 0;
            
            // Animation
            var visibleTog = new BABYLON.Animation("visibleTog", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
            var visibleTog2 = new BABYLON.Animation("visibleTog2", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
              
            var visFrames = [];
            
            visFrames.push({
              frame: 0,
              value: 0,
            });
            
            visFrames.push({
              frame: (168 + i) * frameRate / 2,
              value: 0,
            });
            
            visFrames.push({
              frame: (168 + i) * frameRate / 2,
              value: 1,
            });
            
            visFrames.push({
              frame: (169 + i) * frameRate / 2,
              value: 1,
            });
            
            visFrames.push({
              frame: (169 + i) * frameRate / 2,
              value: 0,
            });
            
            var visFrames2 = [];
        
            visFrames2.push({
              frame: 0,
              value: 0,
            });

            visFrames2.push({
              frame: (169 + i) * frameRate / 2,
              value: 0,
            });

            visFrames2.push({
              frame: (169 + i) * frameRate / 2,
              value: 1
            });

            visibleTog.setKeys(visFrames);
            visibleTog2.setKeys(visFrames2);
            
            scene.beginDirectAnimation(outKeyPlane, [visibleTog], 0, (170 + i) * frameRate / 2, false);
            scene.beginDirectAnimation(outKeyPlane2, [visibleTog2], 0, (170 + i) * frameRate / 2, false);
            
          }

          return outKeys;
          
        }        
                
        /*
         * aesSBox
         *
         * This method reads the SBox.
         *
         * Parameters:
         *  String inHex: SBox location
         *
         * Return value: SBox value
         */
        function aesSBox(inHex) {
          
          var num1 = parseInt(inHex.substring(0, 1), 16);
          var num2 = parseInt(inHex.substring(1), 16);
          
          const frameRate = 10;
          
          var planeWidth = 5;
          var planeHeight = 5;
          
          var DTWidth = planeWidth * 128;
          var DTHeight = planeHeight * 128;
          
          if (iSBox < 40) {
          
            // get the SBox value
            var letter = SBox[num1][num2];
            
            var sboxDynTex = new BABYLON.DynamicTexture("sboxDynTex", {width:DTWidth, height:DTHeight}, scene);
            var ctx = sboxDynTex.getContext();
            var sboxDynTex2 = new BABYLON.DynamicTexture("sboxDynTex2", {width:DTWidth, height:DTHeight}, scene);
            
            // Font sized to fit the plane
            var font_type = "Arial";
            var size = 12;
            var text = "8D";
            ctx.font = size + "px " + font_type;
            var textWidth = ctx.measureText(text).width;
            
            var ratio = textWidth/size;
            
            var font_size = Math.floor(DTWidth / (ratio * 1));
            var font = font_size + "px " + font_type;
            
            var sboxMat = new BABYLON.StandardMaterial("sboxMat", scene);                    
            sboxMat.diffuseTexture = sboxDynTex;
            var sboxMat2 = new BABYLON.StandardMaterial("sboxMat2", scene);                    
            sboxMat2.diffuseTexture = sboxDynTex2;
            
            var sboxPlane = BABYLON.MeshBuilder.CreatePlane("sboxPlane", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            sboxPlane.material = sboxMat;
            sboxDynTex.drawText(letter, null, null, font, "blue", "yellow", true);
            var sboxPlane2 = BABYLON.MeshBuilder.CreatePlane("sboxPlane2", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            sboxPlane2.material = sboxMat2;
            sboxDynTex2.drawText(letter, null, null, font, "blue", "grey", true);
                      
            sboxPlane.position = new BABYLON.Vector3((num2 * -5.55) + 40, (num1 * -5.55) + -5, -70);
            sboxPlane.rotation.y = Math.PI;
            sboxPlane2.position = new BABYLON.Vector3((num2 * -5.55) + 40, (num1 * -5.55) + -5, -70);
            sboxPlane2.rotation.y = Math.PI;
            
            // Animation
            var visibleTog = new BABYLON.Animation("visibleTog", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
            var visibleTog2 = new BABYLON.Animation("visibleTog2", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
            
            var visFrames = [];
            
            visFrames.push({
              frame: 0,
              value: 0,
            });
                      
            visFrames.push({
              frame: ((8 + iSBox) + (i4 * 3)) * frameRate / 2,
              value: 0,
            });
            
            visFrames.push({
              frame: ((8 + iSBox) + (i4 * 3)) * frameRate / 2,
              value: 1,
            });

            visFrames.push({
              frame: ((9 + iSBox) + (i4 * 3)) * frameRate / 2,
              value: 1,
            });

            visFrames.push({
              frame: ((9 + iSBox) + (i4 * 3)) * frameRate / 2,
              value: 0,
            });

            visFrames.push({
              frame: ((24 + iSBox) + (i4 * 3)) * frameRate / 2,
              value: 0,
            });
            
            var visFrames2 = [];
            
            visFrames2.push({
              frame: 0,
              value: 0,
            });
            
            visFrames2.push({
              frame: ((9 + iSBox) + (i4 * 3)) * frameRate / 2,
              value: 0,
            });

            visFrames2.push({
              frame: ((9 + iSBox) + (i4 * 3)) * frameRate / 2,
              value: 1
            });

            visibleTog.setKeys(visFrames);
            visibleTog2.setKeys(visFrames2);
            
            scene.beginDirectAnimation(sboxPlane, [visibleTog], 0, ((24 + iSBox) + (i4 * 3)) * frameRate / 2, false);
            scene.beginDirectAnimation(sboxPlane2, [visibleTog2], 0, ((9 + iSBox) + (i4 * 3)) * frameRate / 2, false);
            
            iSBox++;
            
          } else {
          
            // get the SBox value
            var letter = SBox[num1][num2];
            
            var sboxDynTex = new BABYLON.DynamicTexture("sboxDynTex", {width:DTWidth, height:DTHeight}, scene);
            var ctx = sboxDynTex.getContext();
            var sboxDynTex2 = new BABYLON.DynamicTexture("sboxDynTex2", {width:DTWidth, height:DTHeight}, scene);
            
            // Font sized to fit the plane
            var font_type = "Arial";
            var size = 12;
            var text = "8D";
            ctx.font = size + "px " + font_type;
            var textWidth = ctx.measureText(text).width;
            
            var ratio = textWidth/size;
            
            var font_size = Math.floor(DTWidth / (ratio * 1));
            var font = font_size + "px " + font_type;
            
            var sboxMat = new BABYLON.StandardMaterial("sboxMat", scene);                    
            sboxMat.diffuseTexture = sboxDynTex;
            var sboxMat2 = new BABYLON.StandardMaterial("sboxMat2", scene);                    
            sboxMat2.diffuseTexture = sboxDynTex2;
            
            var sboxPlane = BABYLON.MeshBuilder.CreatePlane("sboxPlane", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            sboxPlane.material = sboxMat;
            sboxDynTex.drawText(letter, null, null, font, "blue", "yellow", true);
            var sboxPlane2 = BABYLON.MeshBuilder.CreatePlane("sboxPlane2", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            sboxPlane2.material = sboxMat2;
            sboxDynTex2.drawText(letter, null, null, font, "blue", "grey", true);
                      
            sboxPlane.position = new BABYLON.Vector3((num2 * -5.55) + 40, (num1 * -5.55) + -5, -70);
            sboxPlane.rotation.y = Math.PI;
            sboxPlane2.position = new BABYLON.Vector3((num2 * -5.55) + 40, (num1 * -5.55) + -5, -70);
            sboxPlane2.rotation.y = Math.PI;
            
            // Animation
            var visibleTog = new BABYLON.Animation("visibleTog", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
            var visibleTog2 = new BABYLON.Animation("visibleTog2", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
            
            var visFrames = [];
            
            visFrames.push({
              frame: 0,
              value: 0,
            });
                      
            visFrames.push({
              frame: ((202 + i4_2) + (iSBox2 * 48)) * frameRate / 2,
              value: 0,
            });
            
            visFrames.push({
              frame: ((202 + i4_2) + (iSBox2 * 48)) * frameRate / 2,
              value: 1,
            });

            visFrames.push({
              frame: ((203 + i4_2) + (iSBox2 * 48)) * frameRate / 2,
              value: 1,
            });

            visFrames.push({
              frame: ((203 + i4_2) + (iSBox2 * 48)) * frameRate / 2, 
              value: 0,
            });

            visFrames.push({
              frame: ((266 + i4_2) + (iSBox2 * 48)) * frameRate / 2,
              value: 0,
            });
            
            var visFrames2 = [];
            
            visFrames2.push({
              frame: 0,
              value: 0,
            });
            
            visFrames2.push({
              frame: ((203 + i4_2) + (iSBox2 * 48)) * frameRate / 2,
              value: 0,
            });

            visFrames2.push({
              frame: ((203 + i4_2) + (iSBox2 * 48)) * frameRate / 2,
              value: 1
            });

            visibleTog.setKeys(visFrames);
            visibleTog2.setKeys(visFrames2);
            
            scene.beginDirectAnimation(sboxPlane, [visibleTog], 0, ((267 + i4_2) + (iSBox2 * 48)) * frameRate / 2, false);
            scene.beginDirectAnimation(sboxPlane2, [visibleTog2], 0, ((267 + i4_2) + (iSBox2 * 48)) * frameRate / 2, false);
            
            i4_2++;
            
          }
          
          return SBox
            [num1]
            [num2];
                                                                 
        }
  
        /*
         * aesRcon
         *
         * This method gets each round's constant.
         *
         * Parameters:
         *  int round: the round number
         *
         * Return value: round's constant
         */
        function aesRcon(round) {
          
          const frameRate = 10;
          
          var planeWidth = 2;
          var planeHeight = 2;
          
          var DTWidth = planeWidth * 128;
          var DTHeight = planeHeight * 128;
          
          // get the RCon value
          var letter = RCon[round];
          
          var rconDynTex = new BABYLON.DynamicTexture("rconDynTex", {width:DTWidth, height:DTHeight}, scene);
          var rconDynTex2 = new BABYLON.DynamicTexture("rconDynTex2", {width:DTWidth, height:DTHeight}, scene);
          var ctx = rconDynTex.getContext();
          
          // Font sized to fit the plane
          var font_type = "Arial";
          var size = 12;
          var text = "8D";
          ctx.font = size + "px " + font_type;
          var textWidth = ctx.measureText(text).width;
          
          var ratio = textWidth/size;
          
          var font_size = Math.floor(DTWidth / (ratio * 1));
          var font = font_size + "px " + font_type;
          
          var rconMat = new BABYLON.StandardMaterial("rconMat", scene);                    
          rconMat.diffuseTexture = rconDynTex;
          var rconMat2 = new BABYLON.StandardMaterial("rconMat2", scene);                    
          rconMat2.diffuseTexture = rconDynTex2;
          
          var rconPlane = BABYLON.MeshBuilder.CreatePlane("rconPlane", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
          rconPlane.material = rconMat;
          rconDynTex.drawText(letter, null, null, font, "blue", "yellow", true);
          var rconPlane2 = BABYLON.MeshBuilder.CreatePlane("rconPlane2", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
          rconPlane2.material = rconMat2;
          rconDynTex2.drawText(letter, null, null, font, "blue", "grey", true);
          
          rconPlane.position = new BABYLON.Vector3((round * 2.25) + -20, -2.25, 27.75);
          rconPlane.rotation.y = 0;
          rconPlane2.position = new BABYLON.Vector3((round * 2.25) + -20, -2.25, 27.75);
          rconPlane2.rotation.y = 0;
          
          // Animation
          var visibleTog = new BABYLON.Animation("visibleTog", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
          var visibleTog2 = new BABYLON.Animation("visibleTog2", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
            
          var visFrames = [];
          
          visFrames.push({
            frame: 0,
            value: 0,
          });

          visFrames.push({
            frame: (8 + (iRCon * 16)) * frameRate / 2,
            value: 0,
          });
          
          visFrames.push({
            frame: (8 + (iRCon * 16)) * frameRate / 2,
            value: 1,
          });

          visFrames.push({
            frame: (12 + (iRCon * 16)) * frameRate / 2,
            value: 1,
          });

          visFrames.push({
            frame: (12 + (iRCon * 16)) * frameRate / 2,
            value: 0,
          });

          visFrames.push({
            frame: (24 + (iRCon * 16)) * frameRate / 2,
            value: 0,
          });

          visibleTog.setKeys(visFrames);
          
          var visFrames2 = [];
          
          visFrames2.push({
            frame: 0,
            value: 0,
          });

          visFrames2.push({
            frame: (12 + (iRCon * 16)) * frameRate / 2,
            value: 0,
          });
          
          visFrames2.push({
            frame: (12 + (iRCon * 16)) * frameRate / 2,
            value: 1,
          });

          visFrames2.push({
            frame: (24 + (iRCon * 16)) * frameRate / 2,
            value: 1,
          });

          visibleTog2.setKeys(visFrames2);
          
          scene.beginDirectAnimation(rconPlane, [visibleTog], 0, (25 + (iRCon * 16)) * frameRate / 2, false);
          scene.beginDirectAnimation(rconPlane2, [visibleTog2], 0, (25 + (iRCon * 16)) * frameRate / 2, false);
          
          iRCon++;
          
          return RCon[round];
              
        }
        
        /*
         * XorHex
         *
         * This method performs the XOR operation.
         *
         * Parameters:
         *  String hex: location value
         *
         * Return value: hex value
         */
         
        function XorHex(... hex) {
          
          var ret = parseInt(hex[0], 16);
          
          for (var i = 1; i < hex.length; i++) {
                       
            ret = ret ^ parseInt(hex[i], 16);
              
          }
          
          var num7 = ret.toString(16).toUpperCase();
              
          if (num7.length < 2) {
            
            var wchar7 = "0" + ret.toString(16).toUpperCase();
                        
          } else {
            
            var wchar7 = ret.toString(16).toUpperCase();
            
          }
          
          const frameRate = 10;
                   
          //Set font
          var font_size = 48;
          var font = "bold " + font_size + "px Arial";
          
          var planeHeight = 2;
                  
          //Set height for dynamic texture
          var DTHeight = 1.5 * font_size; //or set as wished
          
          //Calcultae ratio
          var ratio = planeHeight/DTHeight;
          
          if (iXOR < 40) {
          
            //Use a temporay dynamic texture to calculate the length of the text on the dynamic texture canvas
            var temp = new BABYLON.DynamicTexture("DynamicTexture", 64, scene);
            var tmpctx = temp.getContext();
            tmpctx.font = font;
            var DTWidth = tmpctx.measureText("XorHex").width + 8;     
            
            //Calculate width the plane has to be 
            var planeWidth = DTWidth * ratio;
            
            // Dynamic texture setup
            var planeDynTex = new BABYLON.DynamicTexture("planeDynTex", {width:DTWidth, height:DTHeight}, scene);
            var ctx = planeDynTex.getContext();
            
            var plainMat = new BABYLON.StandardMaterial("plainMat", scene);
            plainMat.diffuseTexture = planeDynTex;
            plainMat.diffuseTexture.hasAlpha = true;
            plainMat.useAlphaFromDiffuseTexture = true;
            
            var plane = BABYLON.MeshBuilder.CreatePlane("plane", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            plane.material = plainMat;
            planeDynTex.drawText("XorHex", null, null, font, "blue", "transparent", true);
                         
            plainMat.onBindObservable.add(() => {
              
              engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
              
            });

            plane.position = new BABYLON.Vector3(-15, -6, 30);
            plane.rotation.y = 0;          
            
            // vchar7 array
            var planeHeight2 = 2;
            var planeWidth2 = 2;
            
            var DTWidth2 = planeWidth2 * 128;
            var DTHeight2 = planeHeight2 * 128;
                                
            var arrayDynTex = new BABYLON.DynamicTexture("arrayDynTex", {width:DTWidth2, height:DTHeight2}, scene);
            var ctx2 = arrayDynTex.getContext();
            
            // Font sized to fit the plane
            var font_type2 = "Arial";
            var size2 = 12;
            var text2 = wchar7;
            ctx2.font = size2 + "px " + font_type2;
            var textWidth2 = ctx2.measureText(text2).width;
            
            var ratio2 = textWidth2/size2;
            
            var font_size2 = Math.floor(DTWidth2 / (ratio2 * 1));
            var font2 = font_size2 + "px " + font_type2;
            
            var arrayMat = new BABYLON.StandardMaterial("arrayMat", scene);                    
            arrayMat.diffuseTexture = arrayDynTex;
            
            var arrayPlane = BABYLON.MeshBuilder.CreatePlane("arrayPlane", {height: planeHeight2, width: planeWidth2, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            arrayPlane.material = arrayMat;
            arrayDynTex.drawText(wchar7, null, null, font2, "blue", "yellow", true);
            
            
            arrayPlane.position = new BABYLON.Vector3(-16, -9, 30);
            arrayPlane.rotation.y = 0;
                        
            // Animation
            var visibleTog = new BABYLON.Animation("visibleTog", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
            
            var visFrames = [];
        
            visFrames.push({
              frame: 0,
              value: 0,
            });
            
            visFrames.push({
              frame: (8 + (iXOR * 4)) * frameRate / 2,
              value: 0,
            });
            
            visFrames.push({
              frame: (8 + (iXOR * 4)) * frameRate / 2,
              value: 1,
            });

            visFrames.push({
              frame: (12 + (iXOR * 4)) * frameRate / 2,
              value: 1,
            });

            visFrames.push({
              frame: (12 + (iXOR * 4)) * frameRate / 2,
              value: 0,
            });

            visibleTog.setKeys(visFrames);
            
            scene.beginDirectAnimation(plane, [visibleTog], 0, (12 + (iXOR * 4)) * frameRate / 2, false);
            scene.beginDirectAnimation(arrayPlane, [visibleTog], 0, (12 + (iXOR * 4)) * frameRate / 2, false);
            
            iXOR++;
            
          }
                    
          return wchar7;
              
        }
        
        /*
         * AESStateXOR
         *
         * This method performs the "Add Round Key" operation. 
         *
         * Parameters:
         *  String[][] sHex: four by four matrix of pairs of hex digits
         *  String[][] keyHex: four by four matrix
         *
         * Return value: XOR of the corresponding input matrix entries
         *  (four by four matrix of pairs of hex digits)
         */
        function AESStateXOR(sHex, keyHex) {
          
          if (sXOR < 1) {
           
            var row = 4, col = 4; 
            var outHex = Array(row).fill().map(() => Array(col));
            
            const frameRate = 10;
                   
            //Set font
            var font_size_stateXOR = 48;
            var font_stateXOR = "bold " + font_size_stateXOR + "px Arial";
            
            var planeHeight_stateXOR = 2;
                    
            //Set height for dynamic texture
            var DTHeight_stateXOR = 1.5 * font_size_stateXOR; //or set as wished
            
            //Calcultae ratio
            var ratioXOR = planeHeight_stateXOR/DTHeight_stateXOR;
            
            //Use a temporay dynamic texture to calculate the length of the text on the dynamic texture canvas
            var temp = new BABYLON.DynamicTexture("DynamicTexture", 64, scene);
            var tmpctx = temp.getContext();
            tmpctx.font = font_stateXOR;
            var DTWidth_stateXOR = tmpctx.measureText("AESStateXOR()").width + 8;
            var DTWidth_stateXOR2 = tmpctx.measureText("state").width + 8;
            var DTWidth_stateXOR3 = tmpctx.measureText("keyExp[0]").width + 8;
            
            //Calculate width the plane has to be 
            var planeWidth_stateXOR = DTWidth_stateXOR * ratioXOR;
            var planeWidth_stateXOR2 = DTWidth_stateXOR2 * ratioXOR;
            var planeWidth_stateXOR3 = DTWidth_stateXOR3 * ratioXOR;
            
            // Dynamic texture setup
            var stateXORPlaneDynTex = new BABYLON.DynamicTexture("stateXORPlaneDynTex", {width:DTWidth_stateXOR, height:DTHeight_stateXOR}, scene);
            var stateXORPlaneDynTex2 = new BABYLON.DynamicTexture("stateXORPlaneDynTex2", {width:DTWidth_stateXOR2, height:DTHeight_stateXOR}, scene);
            var stateXORPlaneDynTex3 = new BABYLON.DynamicTexture("stateXORPlaneDynTex3", {width:DTWidth_stateXOR3, height:DTHeight_stateXOR}, scene);
            // var ctx = stateXORPlaneDynTex.getContext();
            
            var stateXORPlainMat = new BABYLON.StandardMaterial("stateXORPlainMat", scene);
            stateXORPlainMat.diffuseTexture = stateXORPlaneDynTex;
            stateXORPlainMat.diffuseTexture.hasAlpha = true;
            stateXORPlainMat.useAlphaFromDiffuseTexture = true;
            
            var stateXORPlainMat2 = new BABYLON.StandardMaterial("stateXORPlainMat2", scene);
            stateXORPlainMat2.diffuseTexture = stateXORPlaneDynTex2;
            stateXORPlainMat2.diffuseTexture.hasAlpha = true;
            stateXORPlainMat2.useAlphaFromDiffuseTexture = true;
            
            var stateXORPlainMat3 = new BABYLON.StandardMaterial("stateXORPlainMat3", scene);
            stateXORPlainMat3.diffuseTexture = stateXORPlaneDynTex3;
            stateXORPlainMat3.diffuseTexture.hasAlpha = true;
            stateXORPlainMat3.useAlphaFromDiffuseTexture = true;
            
            var stateXORPlane = BABYLON.MeshBuilder.CreatePlane("stateXORPlane", {height: planeHeight_stateXOR, width: planeWidth_stateXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            stateXORPlane.material = stateXORPlainMat;
            stateXORPlaneDynTex.drawText("AESStateXOR()", null, null, font_stateXOR, "blue", "transparent", true);
            
            var stateXORPlane2 = BABYLON.MeshBuilder.CreatePlane("stateXORPlane2", {height: planeHeight_stateXOR, width: planeWidth_stateXOR2, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            stateXORPlane2.material = stateXORPlainMat2;
            stateXORPlaneDynTex2.drawText("state", null, null, font_stateXOR, "blue", "transparent", true);
            
            var stateXORPlane3 = BABYLON.MeshBuilder.CreatePlane("stateXORPlane3", {height: planeHeight_stateXOR, width: planeWidth_stateXOR3, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            stateXORPlane3.material = stateXORPlainMat3;
            stateXORPlaneDynTex3.drawText("keyExp[0]", null, null, font_stateXOR, "blue", "transparent", true);
                         
            stateXORPlainMat.onBindObservable.add(() => {
              
              engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
              
            });   
            
            stateXORPlainMat2.onBindObservable.add(() => {
              
              engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
              
            });
                  
            stateXORPlainMat3.onBindObservable.add(() => {
              
              engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
              
            });

            stateXORPlane.position = new BABYLON.Vector3(30, -12.5, 2);
            stateXORPlane.rotation.y = Math.PI / 2;
            
            stateXORPlane2.position = new BABYLON.Vector3(30, 0, 10);
            stateXORPlane2.rotation.y = Math.PI / 2;
            
            stateXORPlane3.position = new BABYLON.Vector3(30, 0, -2);
            stateXORPlane3.rotation.y = Math.PI / 2;
            
            // Animation
            var visibleTog_stateXOR = new BABYLON.Animation("visibleTog_stateXOR", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
            
            var visFrames_stateXOR = [];
        
            visFrames_stateXOR.push({
              frame: 0,
              value: 0,
            });
            
            visFrames_stateXOR.push({
              frame: 185 * frameRate / 2,
              value: 0,
            });

            visFrames_stateXOR.push({
              frame: 185 * frameRate / 2,
              value: 1,
            });

            visFrames_stateXOR.push({
              frame: 201 * frameRate / 2,
              value: 1,
            });

            visFrames_stateXOR.push({
              frame: 201 * frameRate / 2,
              value: 0,
            });

            visibleTog_stateXOR.setKeys(visFrames_stateXOR);
            
            scene.beginDirectAnimation(stateXORPlane, [visibleTog_stateXOR], 0, 202 * frameRate / 2, false);
            scene.beginDirectAnimation(stateXORPlane2, [visibleTog_stateXOR], 0, 202 * frameRate / 2, false);
            scene.beginDirectAnimation(stateXORPlane3, [visibleTog_stateXOR], 0, 202 * frameRate / 2, false);
                        
            //  initial state Matrix
            var planeWidth_sMatrixXOR = 2;
            var planeHeight_sMatrixXOR = 2;
            
            var DTWidth_sMatrixXOR = planeWidth_sMatrixXOR * 128;
            var DTHeight_sMatrixXOR = planeHeight_sMatrixXOR * 128;
                               
            var i5 = 0;
            
            for (var i = 0; i < 4; i++) {
            
              for (var j = 0; j < 4; j++) {
                
                outHex[i][j] = XorHex(sHex[i][j], keyHex[i][j]);
                var data = outHex[i][j];
                var data2 = sHex[i][j];
                var data3 = keyHex[i][j];
                        
                var toMatrixDynTexXOR = new BABYLON.DynamicTexture("toMatrixDynTexXOR", {width:DTWidth_sMatrixXOR, height:DTHeight_sMatrixXOR}, scene);
                var toMatrixDynTexXOR2 = new BABYLON.DynamicTexture("toMatrixDynTexXOR2", {width:DTWidth_sMatrixXOR, height:DTHeight_sMatrixXOR}, scene);
                var toMatrixDynTexXOR3 = new BABYLON.DynamicTexture("toMatrixDynTexXOR3", {width:DTWidth_sMatrixXOR, height:DTHeight_sMatrixXOR}, scene);
                var toMatrixDynTexXOR4 = new BABYLON.DynamicTexture("toMatrixDynTexXOR4", {width:DTWidth_sMatrixXOR, height:DTHeight_sMatrixXOR}, scene);
                var toMatrixDynTexXOR5 = new BABYLON.DynamicTexture("toMatrixDynTexXOR5", {width:DTWidth_sMatrixXOR, height:DTHeight_sMatrixXOR}, scene);
                var ctxXOR = toMatrixDynTexXOR.getContext();
                
                // Font sized to fit the plane
                var font_type_sMatrixXOR = "Arial";
                var size_sMatrixXOR = 12;
                var text_sMatrixXOR = "8D";
                ctxXOR.font = size_sMatrixXOR + "px " + font_type_sMatrixXOR;
                var textWidth_sMatrixXOR = ctxXOR.measureText(text_sMatrixXOR).width;
                
                var ratio_sMatrixXOR = textWidth_sMatrixXOR/size_sMatrixXOR;
                
                var font_size_sMatrixXOR = Math.floor(DTWidth_sMatrixXOR / (ratio_sMatrixXOR * 1));
                var font_sMatrixXOR = font_size_sMatrixXOR + "px " + font_type_sMatrixXOR;
                
                var toMatrixMatXOR = new BABYLON.StandardMaterial("toMatrixMatXOR", scene);                    
                toMatrixMatXOR.diffuseTexture = toMatrixDynTexXOR;
                var toMatrixMatXOR2 = new BABYLON.StandardMaterial("toMatrixMatXOR2", scene);                    
                toMatrixMatXOR2.diffuseTexture = toMatrixDynTexXOR2;
                var toMatrixMatXOR3 = new BABYLON.StandardMaterial("toMatrixMatXOR3", scene);                    
                toMatrixMatXOR3.diffuseTexture = toMatrixDynTexXOR3;
                var toMatrixMatXOR4 = new BABYLON.StandardMaterial("toMatrixMatXOR4", scene);                    
                toMatrixMatXOR4.diffuseTexture = toMatrixDynTexXOR4;
                var toMatrixMatXOR5 = new BABYLON.StandardMaterial("toMatrixMatXOR5", scene);                    
                toMatrixMatXOR5.diffuseTexture = toMatrixDynTexXOR5;
                
                var toMatrixPlaneXOR = BABYLON.MeshBuilder.CreatePlane("toMatrixPlaneXOR", {height: planeHeight_sMatrixXOR, width: planeWidth_sMatrixXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                toMatrixPlaneXOR.material = toMatrixMatXOR;
                toMatrixDynTexXOR.drawText(data, null, null, font_sMatrixXOR, "blue", "yellow", true);
                
                var toMatrixPlaneXOR2 = BABYLON.MeshBuilder.CreatePlane("toMatrixPlaneXOR2", {height: planeHeight_sMatrixXOR, width: planeWidth_sMatrixXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                toMatrixPlaneXOR2.material = toMatrixMatXOR2;
                toMatrixDynTexXOR2.drawText(data2, null, null, font_sMatrixXOR, "blue", "yellow", true);
                
                var toMatrixPlaneXOR3 = BABYLON.MeshBuilder.CreatePlane("toMatrixPlaneXOR3", {height: planeHeight_sMatrixXOR, width: planeWidth_sMatrixXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                toMatrixPlaneXOR3.material = toMatrixMatXOR3;
                toMatrixDynTexXOR3.drawText(data3, null, null, font_sMatrixXOR, "blue", "yellow", true);
                
                var toMatrixPlaneXOR4 = BABYLON.MeshBuilder.CreatePlane("toMatrixPlaneXOR4", {height: planeHeight_sMatrixXOR, width: planeWidth_sMatrixXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                toMatrixPlaneXOR4.material = toMatrixMatXOR4;
                toMatrixDynTexXOR4.drawText(data2, null, null, font_sMatrixXOR, "blue", "white", true);
                
                var toMatrixPlaneXOR5 = BABYLON.MeshBuilder.CreatePlane("toMatrixPlaneXOR5", {height: planeHeight_sMatrixXOR, width: planeWidth_sMatrixXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                toMatrixPlaneXOR5.material = toMatrixMatXOR5;
                toMatrixDynTexXOR5.drawText(data3, null, null, font_sMatrixXOR, "blue", "white", true);
                                            
                toMatrixPlaneXOR.position = new BABYLON.Vector3(30, (i * -2.25) + -15.25, (j * -2.25) + 5);
                toMatrixPlaneXOR.rotation.y = Math.PI / 2;
                toMatrixPlaneXOR2.position = new BABYLON.Vector3(28, (i * -2.25) + -2.25, (j * -2.25) + 10);
                toMatrixPlaneXOR2.rotation.y = Math.PI / 2;
                toMatrixPlaneXOR3.position = new BABYLON.Vector3(28, (i * -2.25) + -2.25, (j * -2.25) + 0);
                toMatrixPlaneXOR3.rotation.y = Math.PI / 2;
                toMatrixPlaneXOR4.position = new BABYLON.Vector3(30, (i * -2.25) + -2.25, (j * -2.25) + 10);
                toMatrixPlaneXOR4.rotation.y = Math.PI / 2;
                toMatrixPlaneXOR5.position = new BABYLON.Vector3(30, (i * -2.25) + -2.25, (j * -2.25) + 0);
                toMatrixPlaneXOR5.rotation.y = Math.PI / 2;
                
                // Animation
                var visibleTog_sMatrixXOR = new BABYLON.Animation("visibleTog_sMatrixXOR", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                var visibleTog_sMatrixXOR2 = new BABYLON.Animation("visibleTog_sMatrixXOR2", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                var visibleTog_sMatrixXOR3 = new BABYLON.Animation("visibleTog_sMatrixXOR3", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                
                var visFrames_sMatrixXOR = [];
            
                visFrames_sMatrixXOR.push({
                  frame: 0,
                  value: 0,
                });
                
                visFrames_sMatrixXOR.push({
                  frame: (185 + i5) * frameRate / 2,
                  value: 0,
                });

                visFrames_sMatrixXOR.push({
                  frame: (185 + i5) * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR.push({
                  frame: 201 * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR.push({
                  frame: 201 * frameRate / 2,
                  value: 0,
                });

                visibleTog_sMatrixXOR.setKeys(visFrames_sMatrixXOR);
                
                scene.beginDirectAnimation(toMatrixPlaneXOR, [visibleTog_sMatrixXOR], 0, 202 * frameRate / 2, false);
                
                var visFrames_sMatrixXOR2 = [];
            
                visFrames_sMatrixXOR2.push({
                  frame: 0,
                  value: 0,
                });
                
                visFrames_sMatrixXOR2.push({
                  frame: (185 + i5) * frameRate / 2,
                  value: 0,
                });

                visFrames_sMatrixXOR2.push({
                  frame: (185 + i5) * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR2.push({
                  frame: (186 + i5) * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR2.push({
                  frame: (186 + i5) * frameRate / 2,
                  value: 0,
                });
                                
                visibleTog_sMatrixXOR2.setKeys(visFrames_sMatrixXOR2);
                
                scene.beginDirectAnimation(toMatrixPlaneXOR2, [visibleTog_sMatrixXOR2], 0, 202 * frameRate / 2, false);
                scene.beginDirectAnimation(toMatrixPlaneXOR3, [visibleTog_sMatrixXOR2], 0, 202 * frameRate / 2, false);
                
                
                var visFrames_sMatrixXOR3 = [];
            
                visFrames_sMatrixXOR3.push({
                  frame: 0,
                  value: 0,
                });

                visFrames_sMatrixXOR3.push({
                  frame: 185 * frameRate / 2,
                  value: 0,
                });

                visFrames_sMatrixXOR3.push({
                  frame: 185 * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR3.push({
                  frame: 201 * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR3.push({
                  frame: 201 * frameRate / 2,
                  value: 0,
                });
                                
                visibleTog_sMatrixXOR3.setKeys(visFrames_sMatrixXOR3);
                
                scene.beginDirectAnimation(toMatrixPlaneXOR4, [visibleTog_sMatrixXOR3], 0, 202 * frameRate / 2, false);
                scene.beginDirectAnimation(toMatrixPlaneXOR5, [visibleTog_sMatrixXOR3], 0, 202 * frameRate / 2, false);
                
                i5++;
              }
                
            }  
            
            sXOR++;
          
          } else if (sXOR < 10) {
          
            var row = 4, col = 4; 
            var outHex = Array(row).fill().map(() => Array(col));
            
            const frameRate = 10;
                   
            //Set font
            var font_size_stateXOR = 48;
            var font_stateXOR = "bold " + font_size_stateXOR + "px Arial";
            
            var planeHeight_stateXOR = 2;
                    
            //Set height for dynamic texture
            var DTHeight_stateXOR = 1.5 * font_size_stateXOR; //or set as wished
            
            //Calcultae ratio
            var ratioXOR = planeHeight_stateXOR/DTHeight_stateXOR;
            
            //Use a temporay dynamic texture to calculate the length of the text on the dynamic texture canvas
            var temp = new BABYLON.DynamicTexture("DynamicTexture", 64, scene);
            var tmpctx = temp.getContext();
            tmpctx.font = font_stateXOR;
            var DTWidth_stateXOR = tmpctx.measureText("AESStateXOR()").width + 8;
            var DTWidth_stateXOR2 = tmpctx.measureText("state").width + 8;
            var DTWidth_stateXOR3 = tmpctx.measureText("keyExp[0]").width + 8;
            
            //Calculate width the plane has to be 
            var planeWidth_stateXOR = DTWidth_stateXOR * ratioXOR;
            var planeWidth_stateXOR2 = DTWidth_stateXOR2 * ratioXOR;
            var planeWidth_stateXOR3 = DTWidth_stateXOR3 * ratioXOR;
            
            // Dynamic texture setup
            var stateXORPlaneDynTex = new BABYLON.DynamicTexture("stateXORPlaneDynTex", {width:DTWidth_stateXOR, height:DTHeight_stateXOR}, scene);
            var stateXORPlaneDynTex2 = new BABYLON.DynamicTexture("stateXORPlaneDynTex2", {width:DTWidth_stateXOR2, height:DTHeight_stateXOR}, scene);
            var stateXORPlaneDynTex3 = new BABYLON.DynamicTexture("stateXORPlaneDynTex3", {width:DTWidth_stateXOR3, height:DTHeight_stateXOR}, scene);
            // var ctx = stateXORPlaneDynTex.getContext();
            
            var stateXORPlainMat = new BABYLON.StandardMaterial("stateXORPlainMat", scene);
            stateXORPlainMat.diffuseTexture = stateXORPlaneDynTex;
            stateXORPlainMat.diffuseTexture.hasAlpha = true;
            stateXORPlainMat.useAlphaFromDiffuseTexture = true;
            
            var stateXORPlainMat2 = new BABYLON.StandardMaterial("stateXORPlainMat2", scene);
            stateXORPlainMat2.diffuseTexture = stateXORPlaneDynTex2;
            stateXORPlainMat2.diffuseTexture.hasAlpha = true;
            stateXORPlainMat2.useAlphaFromDiffuseTexture = true;
            
            var stateXORPlainMat3 = new BABYLON.StandardMaterial("stateXORPlainMat3", scene);
            stateXORPlainMat3.diffuseTexture = stateXORPlaneDynTex3;
            stateXORPlainMat3.diffuseTexture.hasAlpha = true;
            stateXORPlainMat3.useAlphaFromDiffuseTexture = true;
            
            var stateXORPlane = BABYLON.MeshBuilder.CreatePlane("stateXORPlane", {height: planeHeight_stateXOR, width: planeWidth_stateXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            stateXORPlane.material = stateXORPlainMat;
            stateXORPlaneDynTex.drawText("AESStateXOR()", null, null, font_stateXOR, "blue", "transparent", true);
            
            var stateXORPlane2 = BABYLON.MeshBuilder.CreatePlane("stateXORPlane2", {height: planeHeight_stateXOR, width: planeWidth_stateXOR2, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            stateXORPlane2.material = stateXORPlainMat2;
            stateXORPlaneDynTex2.drawText("state", null, null, font_stateXOR, "blue", "transparent", true);
            
            var stateXORPlane3 = BABYLON.MeshBuilder.CreatePlane("stateXORPlane3", {height: planeHeight_stateXOR, width: planeWidth_stateXOR3, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            stateXORPlane3.material = stateXORPlainMat3;
            stateXORPlaneDynTex3.drawText("keyExp[0]", null, null, font_stateXOR, "blue", "transparent", true);
                         
            stateXORPlainMat.onBindObservable.add(() => {
              
              engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
              
            });   
            
            stateXORPlainMat2.onBindObservable.add(() => {
              
              engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
              
            });
                  
            stateXORPlainMat3.onBindObservable.add(() => {
              
              engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
              
            });

            stateXORPlane.position = new BABYLON.Vector3(30, -12.75, -3);
            stateXORPlane.rotation.y = Math.PI / 2;
            
            stateXORPlane2.position = new BABYLON.Vector3(30, -25.25, 10);
            stateXORPlane2.rotation.y = Math.PI / 2;
            
            stateXORPlane3.position = new BABYLON.Vector3(30, -25.25, -16);
            stateXORPlane3.rotation.y = Math.PI / 2;
            
            // Animation
            var visibleTog_stateXOR = new BABYLON.Animation("visibleTog_stateXOR", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
            
            var visFrames_stateXOR = [];
        
            visFrames_stateXOR.push({
              frame: 0,
              value: 0,
            });
            
            visFrames_stateXOR.push({
              frame: (250 + (sXOR2 * 64)) * frameRate / 2,
              value: 0,
            });

            visFrames_stateXOR.push({
              frame: (250 + (sXOR2 * 64)) * frameRate / 2,
              value: 1,
            });

            visFrames_stateXOR.push({
              frame: (266 + (sXOR2 * 64)) * frameRate / 2,
              value: 1,
            });

            visFrames_stateXOR.push({
              frame: (266 + (sXOR2 * 64)) * frameRate / 2,
              value: 0,
            });

            visibleTog_stateXOR.setKeys(visFrames_stateXOR);
            
            scene.beginDirectAnimation(stateXORPlane, [visibleTog_stateXOR], 0, (267 + (sXOR2 * 64)) * frameRate / 2, false);
            scene.beginDirectAnimation(stateXORPlane2, [visibleTog_stateXOR], 0, (267 + (sXOR2 * 64)) * frameRate / 2, false);
            scene.beginDirectAnimation(stateXORPlane3, [visibleTog_stateXOR], 0, (267 + (sXOR2 * 64)) * frameRate / 2, false);
                        
            //  initial state Matrix
            var planeWidth_sMatrixXOR = 2;
            var planeHeight_sMatrixXOR = 2;
            
            var DTWidth_sMatrixXOR = planeWidth_sMatrixXOR * 128;
            var DTHeight_sMatrixXOR = planeHeight_sMatrixXOR * 128;
                               
            var i5 = 0;
            
            for (var i = 0; i < 4; i++) {
            
              for (var j = 0; j < 4; j++) {
                
                outHex[i][j] = XorHex(sHex[i][j], keyHex[i][j]);
                var data = outHex[i][j];
                var data2 = sHex[i][j];
                var data3 = keyHex[i][j];
                        
                var toMatrixDynTexXOR = new BABYLON.DynamicTexture("toMatrixDynTexXOR", {width:DTWidth_sMatrixXOR, height:DTHeight_sMatrixXOR}, scene);
                var toMatrixDynTexXOR2 = new BABYLON.DynamicTexture("toMatrixDynTexXOR2", {width:DTWidth_sMatrixXOR, height:DTHeight_sMatrixXOR}, scene);
                var toMatrixDynTexXOR3 = new BABYLON.DynamicTexture("toMatrixDynTexXOR3", {width:DTWidth_sMatrixXOR, height:DTHeight_sMatrixXOR}, scene);
                var toMatrixDynTexXOR4 = new BABYLON.DynamicTexture("toMatrixDynTexXOR4", {width:DTWidth_sMatrixXOR, height:DTHeight_sMatrixXOR}, scene);
                var toMatrixDynTexXOR5 = new BABYLON.DynamicTexture("toMatrixDynTexXOR5", {width:DTWidth_sMatrixXOR, height:DTHeight_sMatrixXOR}, scene);
                var ctxXOR = toMatrixDynTexXOR.getContext();
                
                // Font sized to fit the plane
                var font_type_sMatrixXOR = "Arial";
                var size_sMatrixXOR = 12;
                var text_sMatrixXOR = "8D";
                ctxXOR.font = size_sMatrixXOR + "px " + font_type_sMatrixXOR;
                var textWidth_sMatrixXOR = ctxXOR.measureText(text_sMatrixXOR).width;
                
                var ratio_sMatrixXOR = textWidth_sMatrixXOR/size_sMatrixXOR;
                
                var font_size_sMatrixXOR = Math.floor(DTWidth_sMatrixXOR / (ratio_sMatrixXOR * 1));
                var font_sMatrixXOR = font_size_sMatrixXOR + "px " + font_type_sMatrixXOR;
                
                var toMatrixMatXOR = new BABYLON.StandardMaterial("toMatrixMatXOR", scene);                    
                toMatrixMatXOR.diffuseTexture = toMatrixDynTexXOR;
                var toMatrixMatXOR2 = new BABYLON.StandardMaterial("toMatrixMatXOR2", scene);                    
                toMatrixMatXOR2.diffuseTexture = toMatrixDynTexXOR2;
                var toMatrixMatXOR3 = new BABYLON.StandardMaterial("toMatrixMatXOR3", scene);                    
                toMatrixMatXOR3.diffuseTexture = toMatrixDynTexXOR3;
                var toMatrixMatXOR4 = new BABYLON.StandardMaterial("toMatrixMatXOR4", scene);                    
                toMatrixMatXOR4.diffuseTexture = toMatrixDynTexXOR4;
                var toMatrixMatXOR5 = new BABYLON.StandardMaterial("toMatrixMatXOR5", scene);                    
                toMatrixMatXOR5.diffuseTexture = toMatrixDynTexXOR5;
                
                var toMatrixPlaneXOR = BABYLON.MeshBuilder.CreatePlane("toMatrixPlaneXOR", {height: planeHeight_sMatrixXOR, width: planeWidth_sMatrixXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                toMatrixPlaneXOR.material = toMatrixMatXOR;
                toMatrixDynTexXOR.drawText(data, null, null, font_sMatrixXOR, "blue", "yellow", true);
                
                var toMatrixPlaneXOR2 = BABYLON.MeshBuilder.CreatePlane("toMatrixPlaneXOR2", {height: planeHeight_sMatrixXOR, width: planeWidth_sMatrixXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                toMatrixPlaneXOR2.material = toMatrixMatXOR2;
                toMatrixDynTexXOR2.drawText(data2, null, null, font_sMatrixXOR, "blue", "yellow", true);
                
                var toMatrixPlaneXOR3 = BABYLON.MeshBuilder.CreatePlane("toMatrixPlaneXOR3", {height: planeHeight_sMatrixXOR, width: planeWidth_sMatrixXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                toMatrixPlaneXOR3.material = toMatrixMatXOR3;
                toMatrixDynTexXOR3.drawText(data3, null, null, font_sMatrixXOR, "blue", "yellow", true);
                
                var toMatrixPlaneXOR4 = BABYLON.MeshBuilder.CreatePlane("toMatrixPlaneXOR4", {height: planeHeight_sMatrixXOR, width: planeWidth_sMatrixXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                toMatrixPlaneXOR4.material = toMatrixMatXOR4;
                toMatrixDynTexXOR4.drawText(data2, null, null, font_sMatrixXOR, "blue", "white", true);
                
                var toMatrixPlaneXOR5 = BABYLON.MeshBuilder.CreatePlane("toMatrixPlaneXOR5", {height: planeHeight_sMatrixXOR, width: planeWidth_sMatrixXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                toMatrixPlaneXOR5.material = toMatrixMatXOR5;
                toMatrixDynTexXOR5.drawText(data3, null, null, font_sMatrixXOR, "blue", "white", true);
                                            
                toMatrixPlaneXOR.position = new BABYLON.Vector3(28, (i * -2.25) + -15, (j * -2.25) + 1);
                toMatrixPlaneXOR.rotation.y = Math.PI / 2;
                toMatrixPlaneXOR2.position = new BABYLON.Vector3(28, (i * -2.25) + -27.5, (j * -2.25) + 13);
                toMatrixPlaneXOR2.rotation.y = Math.PI / 2;
                toMatrixPlaneXOR3.position = new BABYLON.Vector3(28, (i * -2.25) + -27.5, (j * -2.25) + -12);
                toMatrixPlaneXOR3.rotation.y = Math.PI / 2;
                toMatrixPlaneXOR4.position = new BABYLON.Vector3(30, (i * -2.25) + -27.5, (j * -2.25) + 13);
                toMatrixPlaneXOR4.rotation.y = Math.PI / 2;
                toMatrixPlaneXOR5.position = new BABYLON.Vector3(30, (i * -2.25) + -27.5, (j * -2.25) + -12);
                toMatrixPlaneXOR5.rotation.y = Math.PI / 2;
                
                // Animation
                var visibleTog_sMatrixXOR = new BABYLON.Animation("visibleTog_sMatrixXOR", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                var visibleTog_sMatrixXOR2 = new BABYLON.Animation("visibleTog_sMatrixXOR2", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                var visibleTog_sMatrixXOR3 = new BABYLON.Animation("visibleTog_sMatrixXOR3", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                
                var visFrames_sMatrixXOR = [];
            
                visFrames_sMatrixXOR.push({
                  frame: 0,
                  value: 0,
                });
                
                visFrames_sMatrixXOR.push({
                  frame: ((250 + i5) + (sXOR2 * 64)) * frameRate / 2,
                  value: 0,
                });

                visFrames_sMatrixXOR.push({
                  frame: ((250 + i5) + (sXOR2 * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR.push({
                  frame: (266 + (sXOR2 * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR.push({
                  frame: (266 + (sXOR2 * 64)) * frameRate / 2,
                  value: 0,
                });

                visibleTog_sMatrixXOR.setKeys(visFrames_sMatrixXOR);
                
                scene.beginDirectAnimation(toMatrixPlaneXOR, [visibleTog_sMatrixXOR], 0, (267 + (sXOR2 * 64)) * frameRate / 2, false);
                
                var visFrames_sMatrixXOR2 = [];
            
                visFrames_sMatrixXOR2.push({
                  frame: 0,
                  value: 0,
                });
                
                visFrames_sMatrixXOR2.push({
                  frame: ((250 + i5) + (sXOR2 * 64)) * frameRate / 2,
                  value: 0,
                });

                visFrames_sMatrixXOR2.push({
                  frame: ((250 + i5) + (sXOR2 * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR2.push({
                  frame: ((251 + i5) + (sXOR2 * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR2.push({
                  frame: ((251 + i5) + (sXOR2 * 64)) * frameRate / 2,
                  value: 0,
                });
                                
                visibleTog_sMatrixXOR2.setKeys(visFrames_sMatrixXOR2);
                
                scene.beginDirectAnimation(toMatrixPlaneXOR2, [visibleTog_sMatrixXOR2], 0, (267 + (sXOR2 * 64)) * frameRate / 2, false);
                scene.beginDirectAnimation(toMatrixPlaneXOR3, [visibleTog_sMatrixXOR2], 0, (267 + (sXOR2 * 64)) * frameRate / 2, false);
                
                
                var visFrames_sMatrixXOR3 = [];
            
                visFrames_sMatrixXOR3.push({
                  frame: 0,
                  value: 0,
                });

                visFrames_sMatrixXOR3.push({
                  frame: (250 + (sXOR2 * 64)) * frameRate / 2,
                  value: 0,
                });

                visFrames_sMatrixXOR3.push({
                  frame: (250 + (sXOR2 * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR3.push({
                  frame: (266 + (sXOR2 * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR3.push({
                  frame: (266 + (sXOR2 * 64)) * frameRate / 2,
                  value: 0,
                });
                                
                visibleTog_sMatrixXOR3.setKeys(visFrames_sMatrixXOR3);
                
                scene.beginDirectAnimation(toMatrixPlaneXOR4, [visibleTog_sMatrixXOR3], 0, (267 + (sXOR2 * 64)) * frameRate / 2, false);
                scene.beginDirectAnimation(toMatrixPlaneXOR5, [visibleTog_sMatrixXOR3], 0, (267 + (sXOR2 * 64)) * frameRate / 2, false);
                
                i5++;
                
              }
                
            }  
            
            sXOR++;
            sXOR2++;
              
          } else {
          
            var row = 4, col = 4; 
            var outHex = Array(row).fill().map(() => Array(col));
            
            const frameRate = 10;
                   
            //Set font
            var font_size_stateXOR = 48;
            var font_stateXOR = "bold " + font_size_stateXOR + "px Arial";
            
            var planeHeight_stateXOR = 2;
                    
            //Set height for dynamic texture
            var DTHeight_stateXOR = 1.5 * font_size_stateXOR; //or set as wished
            
            //Calcultae ratio
            var ratioXOR = planeHeight_stateXOR/DTHeight_stateXOR;
            
            //Use a temporay dynamic texture to calculate the length of the text on the dynamic texture canvas
            var temp = new BABYLON.DynamicTexture("DynamicTexture", 64, scene);
            var tmpctx = temp.getContext();
            tmpctx.font = font_stateXOR;
            var DTWidth_stateXOR = tmpctx.measureText("AESStateXOR()").width + 8;
            var DTWidth_stateXOR2 = tmpctx.measureText("state").width + 8;
            var DTWidth_stateXOR3 = tmpctx.measureText("keyExp[0]").width + 8;
            
            //Calculate width the plane has to be 
            var planeWidth_stateXOR = DTWidth_stateXOR * ratioXOR;
            var planeWidth_stateXOR2 = DTWidth_stateXOR2 * ratioXOR;
            var planeWidth_stateXOR3 = DTWidth_stateXOR3 * ratioXOR;
            
            // Dynamic texture setup
            var stateXORPlaneDynTex = new BABYLON.DynamicTexture("stateXORPlaneDynTex", {width:DTWidth_stateXOR, height:DTHeight_stateXOR}, scene);
            var stateXORPlaneDynTex2 = new BABYLON.DynamicTexture("stateXORPlaneDynTex2", {width:DTWidth_stateXOR2, height:DTHeight_stateXOR}, scene);
            var stateXORPlaneDynTex3 = new BABYLON.DynamicTexture("stateXORPlaneDynTex3", {width:DTWidth_stateXOR3, height:DTHeight_stateXOR}, scene);
            
            var stateXORPlainMat = new BABYLON.StandardMaterial("stateXORPlainMat", scene);
            stateXORPlainMat.diffuseTexture = stateXORPlaneDynTex;
            stateXORPlainMat.diffuseTexture.hasAlpha = true;
            stateXORPlainMat.useAlphaFromDiffuseTexture = true;
            
            var stateXORPlainMat2 = new BABYLON.StandardMaterial("stateXORPlainMat2", scene);
            stateXORPlainMat2.diffuseTexture = stateXORPlaneDynTex2;
            stateXORPlainMat2.diffuseTexture.hasAlpha = true;
            stateXORPlainMat2.useAlphaFromDiffuseTexture = true;
            
            var stateXORPlainMat3 = new BABYLON.StandardMaterial("stateXORPlainMat3", scene);
            stateXORPlainMat3.diffuseTexture = stateXORPlaneDynTex3;
            stateXORPlainMat3.diffuseTexture.hasAlpha = true;
            stateXORPlainMat3.useAlphaFromDiffuseTexture = true;
            
            var stateXORPlane = BABYLON.MeshBuilder.CreatePlane("stateXORPlane", {height: planeHeight_stateXOR, width: planeWidth_stateXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            stateXORPlane.material = stateXORPlainMat;
            stateXORPlaneDynTex.drawText("AESStateXOR()", null, null, font_stateXOR, "blue", "transparent", true);
            
            var stateXORPlane2 = BABYLON.MeshBuilder.CreatePlane("stateXORPlane2", {height: planeHeight_stateXOR, width: planeWidth_stateXOR2, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            stateXORPlane2.material = stateXORPlainMat2;
            stateXORPlaneDynTex2.drawText("state", null, null, font_stateXOR, "blue", "transparent", true);
            
            var stateXORPlane3 = BABYLON.MeshBuilder.CreatePlane("stateXORPlane3", {height: planeHeight_stateXOR, width: planeWidth_stateXOR3, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            stateXORPlane3.material = stateXORPlainMat3;
            stateXORPlaneDynTex3.drawText("keyExp[0]", null, null, font_stateXOR, "blue", "transparent", true);
                         
            stateXORPlainMat.onBindObservable.add(() => {
              
              engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
              
            });   
            
            stateXORPlainMat2.onBindObservable.add(() => {
              
              engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
              
            });
                  
            stateXORPlainMat3.onBindObservable.add(() => {
              
              engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
              
            });

            stateXORPlane.position = new BABYLON.Vector3(30, -12.75, -3);
            stateXORPlane.rotation.y = Math.PI / 2;
            
            stateXORPlane2.position = new BABYLON.Vector3(30, -25.25, 10);
            stateXORPlane2.rotation.y = Math.PI / 2;
            
            stateXORPlane3.position = new BABYLON.Vector3(30, -25.25, -16);
            stateXORPlane3.rotation.y = Math.PI / 2;
            
            // Animation
            var visibleTog_stateXOR = new BABYLON.Animation("visibleTog_stateXOR", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
            
            var visFrames_stateXOR = [];
        
            visFrames_stateXOR.push({
              frame: 0,
              value: 0,
            });
            
            visFrames_stateXOR.push({
              frame: 810 * frameRate / 2,
              value: 0,
            });

            visFrames_stateXOR.push({
              frame: 810 * frameRate / 2,
              value: 1,
            });

            visFrames_stateXOR.push({
              frame: 811 * frameRate / 2,
              value: 1,
            });

            visFrames_stateXOR.push({
              frame: 842 * frameRate / 2,
              value: 1,
            });

            visibleTog_stateXOR.setKeys(visFrames_stateXOR);
            
            scene.beginDirectAnimation(stateXORPlane, [visibleTog_stateXOR], 0, 842 * frameRate / 2, false);
            scene.beginDirectAnimation(stateXORPlane2, [visibleTog_stateXOR], 0, 842 * frameRate / 2, false);
            scene.beginDirectAnimation(stateXORPlane3, [visibleTog_stateXOR], 0, 842 * frameRate / 2, false);
                        
            //  initial state Matrix
            var planeWidth_sMatrixXOR = 2;
            var planeHeight_sMatrixXOR = 2;
            
            var DTWidth_sMatrixXOR = planeWidth_sMatrixXOR * 128;
            var DTHeight_sMatrixXOR = planeHeight_sMatrixXOR * 128;
                               
            var i5 = 0;
            
            for (var i = 0; i < 4; i++) {
            
              for (var j = 0; j < 4; j++) {
                
                outHex[i][j] = XorHex(sHex[i][j], keyHex[i][j]);
                var data = outHex[i][j];
                var data2 = sHex[i][j];
                var data3 = keyHex[i][j];
                        
                var toMatrixDynTexXOR = new BABYLON.DynamicTexture("toMatrixDynTexXOR", {width:DTWidth_sMatrixXOR, height:DTHeight_sMatrixXOR}, scene);
                var toMatrixDynTexXOR2 = new BABYLON.DynamicTexture("toMatrixDynTexXOR2", {width:DTWidth_sMatrixXOR, height:DTHeight_sMatrixXOR}, scene);
                var toMatrixDynTexXOR3 = new BABYLON.DynamicTexture("toMatrixDynTexXOR3", {width:DTWidth_sMatrixXOR, height:DTHeight_sMatrixXOR}, scene);
                var toMatrixDynTexXOR4 = new BABYLON.DynamicTexture("toMatrixDynTexXOR4", {width:DTWidth_sMatrixXOR, height:DTHeight_sMatrixXOR}, scene);
                var toMatrixDynTexXOR5 = new BABYLON.DynamicTexture("toMatrixDynTexXOR5", {width:DTWidth_sMatrixXOR, height:DTHeight_sMatrixXOR}, scene);
                var ctxXOR = toMatrixDynTexXOR.getContext();
                
                // Font sized to fit the plane
                var font_type_sMatrixXOR = "Arial";
                var size_sMatrixXOR = 12;
                var text_sMatrixXOR = "8D";
                ctxXOR.font = size_sMatrixXOR + "px " + font_type_sMatrixXOR;
                var textWidth_sMatrixXOR = ctxXOR.measureText(text_sMatrixXOR).width;
                
                var ratio_sMatrixXOR = textWidth_sMatrixXOR/size_sMatrixXOR;
                
                var font_size_sMatrixXOR = Math.floor(DTWidth_sMatrixXOR / (ratio_sMatrixXOR * 1));
                var font_sMatrixXOR = font_size_sMatrixXOR + "px " + font_type_sMatrixXOR;
                
                var toMatrixMatXOR = new BABYLON.StandardMaterial("toMatrixMatXOR", scene);                    
                toMatrixMatXOR.diffuseTexture = toMatrixDynTexXOR;
                var toMatrixMatXOR2 = new BABYLON.StandardMaterial("toMatrixMatXOR2", scene);                    
                toMatrixMatXOR2.diffuseTexture = toMatrixDynTexXOR2;
                var toMatrixMatXOR3 = new BABYLON.StandardMaterial("toMatrixMatXOR3", scene);                    
                toMatrixMatXOR3.diffuseTexture = toMatrixDynTexXOR3;
                var toMatrixMatXOR4 = new BABYLON.StandardMaterial("toMatrixMatXOR4", scene);                    
                toMatrixMatXOR4.diffuseTexture = toMatrixDynTexXOR4;
                var toMatrixMatXOR5 = new BABYLON.StandardMaterial("toMatrixMatXOR5", scene);                    
                toMatrixMatXOR5.diffuseTexture = toMatrixDynTexXOR5;
                
                var toMatrixPlaneXOR = BABYLON.MeshBuilder.CreatePlane("toMatrixPlaneXOR", {height: planeHeight_sMatrixXOR, width: planeWidth_sMatrixXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                toMatrixPlaneXOR.material = toMatrixMatXOR;
                toMatrixDynTexXOR.drawText(data, null, null, font_sMatrixXOR, "blue", "yellow", true);
                
                var toMatrixPlaneXOR2 = BABYLON.MeshBuilder.CreatePlane("toMatrixPlaneXOR2", {height: planeHeight_sMatrixXOR, width: planeWidth_sMatrixXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                toMatrixPlaneXOR2.material = toMatrixMatXOR2;
                toMatrixDynTexXOR2.drawText(data2, null, null, font_sMatrixXOR, "blue", "yellow", true);
                
                var toMatrixPlaneXOR3 = BABYLON.MeshBuilder.CreatePlane("toMatrixPlaneXOR3", {height: planeHeight_sMatrixXOR, width: planeWidth_sMatrixXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                toMatrixPlaneXOR3.material = toMatrixMatXOR3;
                toMatrixDynTexXOR3.drawText(data3, null, null, font_sMatrixXOR, "blue", "yellow", true);
                
                var toMatrixPlaneXOR4 = BABYLON.MeshBuilder.CreatePlane("toMatrixPlaneXOR4", {height: planeHeight_sMatrixXOR, width: planeWidth_sMatrixXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                toMatrixPlaneXOR4.material = toMatrixMatXOR4;
                toMatrixDynTexXOR4.drawText(data2, null, null, font_sMatrixXOR, "blue", "white", true);
                
                var toMatrixPlaneXOR5 = BABYLON.MeshBuilder.CreatePlane("toMatrixPlaneXOR5", {height: planeHeight_sMatrixXOR, width: planeWidth_sMatrixXOR, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                toMatrixPlaneXOR5.material = toMatrixMatXOR5;
                toMatrixDynTexXOR5.drawText(data3, null, null, font_sMatrixXOR, "blue", "white", true);
                                            
                toMatrixPlaneXOR.position = new BABYLON.Vector3(28, (i * -2.25) + -15, (j * -2.25) + 1);
                toMatrixPlaneXOR.rotation.y = Math.PI / 2;
                toMatrixPlaneXOR2.position = new BABYLON.Vector3(28, (i * -2.25) + -27.5, (j * -2.25) + 13);
                toMatrixPlaneXOR2.rotation.y = Math.PI / 2;
                toMatrixPlaneXOR3.position = new BABYLON.Vector3(28, (i * -2.25) + -27.5, (j * -2.25) + -12);
                toMatrixPlaneXOR3.rotation.y = Math.PI / 2;
                toMatrixPlaneXOR4.position = new BABYLON.Vector3(30, (i * -2.25) + -27.5, (j * -2.25) + 13);
                toMatrixPlaneXOR4.rotation.y = Math.PI / 2;
                toMatrixPlaneXOR5.position = new BABYLON.Vector3(30, (i * -2.25) + -27.5, (j * -2.25) + -12);
                toMatrixPlaneXOR5.rotation.y = Math.PI / 2;
                
                // Animation
                var visibleTog_sMatrixXOR = new BABYLON.Animation("visibleTog_sMatrixXOR", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                var visibleTog_sMatrixXOR2 = new BABYLON.Animation("visibleTog_sMatrixXOR2", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                var visibleTog_sMatrixXOR3 = new BABYLON.Animation("visibleTog_sMatrixXOR3", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                
                var visFrames_sMatrixXOR = [];
            
                visFrames_sMatrixXOR.push({
                  frame: 0,
                  value: 0,
                });
                
                visFrames_sMatrixXOR.push({
                  frame: (810 + i5) * frameRate / 2,
                  value: 0,
                });

                visFrames_sMatrixXOR.push({
                  frame: (810 + i5) * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR.push({
                  frame: 811 * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR.push({
                  frame: 842 * frameRate / 2,
                  value: 1,
                });

                visibleTog_sMatrixXOR.setKeys(visFrames_sMatrixXOR);
                
                scene.beginDirectAnimation(toMatrixPlaneXOR, [visibleTog_sMatrixXOR], 0, 842 * frameRate / 2, false);
                
                var visFrames_sMatrixXOR2 = [];
            
                visFrames_sMatrixXOR2.push({
                  frame: 0,
                  value: 0,
                });
                
                visFrames_sMatrixXOR2.push({
                  frame: (810 + i5) * frameRate / 2,
                  value: 0,
                });

                visFrames_sMatrixXOR2.push({
                  frame: (810 + i5) * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR2.push({
                  frame: (811 + i5) * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR2.push({
                  frame: (811 + i5) * frameRate / 2,
                  value: 0,
                });

                visFrames_sMatrixXOR.push({
                  frame: 842 * frameRate / 2,
                  value: 1,
                });
                                
                visibleTog_sMatrixXOR2.setKeys(visFrames_sMatrixXOR2);
                
                scene.beginDirectAnimation(toMatrixPlaneXOR2, [visibleTog_sMatrixXOR2], 0, 842 * frameRate / 2, false);
                scene.beginDirectAnimation(toMatrixPlaneXOR3, [visibleTog_sMatrixXOR2], 0, 842 * frameRate / 2, false);
                
                
                var visFrames_sMatrixXOR3 = [];
            
                visFrames_sMatrixXOR3.push({
                  frame: 0,
                  value: 0,
                });

                visFrames_sMatrixXOR3.push({
                  frame: 810 * frameRate / 2,
                  value: 0,
                });

                visFrames_sMatrixXOR3.push({
                  frame: 810 * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR3.push({
                  frame: 811 * frameRate / 2,
                  value: 1,
                });

                visFrames_sMatrixXOR3.push({
                  frame: 842 * frameRate / 2,
                  value: 1,
                });
                                
                visibleTog_sMatrixXOR3.setKeys(visFrames_sMatrixXOR3);
                
                scene.beginDirectAnimation(toMatrixPlaneXOR4, [visibleTog_sMatrixXOR3], 0, 842 * frameRate / 2, false);
                scene.beginDirectAnimation(toMatrixPlaneXOR5, [visibleTog_sMatrixXOR3], 0, 842 * frameRate / 2, false);
                
                i5++;
                
              }
                
            }  
                     
          }
                  
          return outHex;
            
        }
        
        /*
         * AESNibbleSub
         *
         * This method performs the "Substitution" operation by running the input matrix
         * entries through the AES SBox.
         *
         * Parameters:
         *  String[][] inHex: four by four matrix of pairs of hex digits
         *
         * Return value: four by four matrix of pairs of hex digits
         */
        function AESNibbleSub(inHex) {
          
          // outHex and aesSBOX work in conjunction together
          
          if (iNibble < 10) {
          
            var row = 4, col = 4; 
            var outHex = Array(row).fill().map(() => Array(col));
            
            const frameRate = 10;
      
            //Set font
            var font_size_nibble = 48;
            var font_state_nibble = "bold " + font_size_nibble + "px Arial";
            
            var planeHeight_state_nibble = 2;
                    
            //Set height for dynamic texture
            var DTHeight_state_nibble = 1.5 * font_size_nibble; //or set as wished
            
            //Calcultae ratio
            var ratio_nibble = planeHeight_state_nibble/DTHeight_state_nibble;
            
            //Use a temporay dynamic texture to calculate the length of the text on the dynamic texture canvas
            var temp = new BABYLON.DynamicTexture("DynamicTexture", 64, scene);
            var tmpctx = temp.getContext();
            tmpctx.font = font_state_nibble;
            var DTWidth_state_nibble = tmpctx.measureText("AESNibbleSub()").width + 8;
            
            //Calculate width the plane has to be 
            var planeWidth_state_nibble = DTWidth_state_nibble * ratio_nibble;
            
            // Dynamic texture setup
            var state_nibble_PlaneDynTex = new BABYLON.DynamicTexture("state_nibble_PlaneDynTex", {width:DTWidth_state_nibble, height:DTHeight_state_nibble}, scene);
            
            var state_nibble_PlainMat = new BABYLON.StandardMaterial("state_nibble_PlainMat", scene);
            state_nibble_PlainMat.diffuseTexture = state_nibble_PlaneDynTex;
            state_nibble_PlainMat.diffuseTexture.hasAlpha = true;
            state_nibble_PlainMat.useAlphaFromDiffuseTexture = true;
            
            var state_nibble_Plane = BABYLON.MeshBuilder.CreatePlane("state_nibble_Plane", {height: planeHeight_state_nibble, width: planeWidth_state_nibble, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            state_nibble_Plane.material = state_nibble_PlainMat;
            state_nibble_PlaneDynTex.drawText("AESNibbleSub()", null, null, font_state_nibble, "blue", "transparent", true);
                         
            state_nibble_PlainMat.onBindObservable.add(() => {
              
              engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
              
            });
            
            state_nibble_Plane.position = new BABYLON.Vector3(30, 0, 10);
            state_nibble_Plane.rotation.y = Math.PI / 2;
            
            // Animation
            var visibleTog_state_nibble = new BABYLON.Animation("visibleTog_state_nibble", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
            
            var visFrames_state_nibble = [];
            
            visFrames_state_nibble.push({
              frame: 0,
              value: 0,
            });
            
            visFrames_state_nibble.push({
              frame: (202 + (iNibble * 64)) * frameRate / 2,
              value: 0,
            });

            visFrames_state_nibble.push({
              frame: (202 + (iNibble * 64)) * frameRate / 2,
              value: 1,
            });

            visFrames_state_nibble.push({
              frame: (266 + (iNibble * 64)) * frameRate / 2,
              value: 1,
            });

            visFrames_state_nibble.push({
              frame: (266 + (iNibble * 64)) * frameRate / 2,
              value: 0,
            });

            visibleTog_state_nibble.setKeys(visFrames_state_nibble);
            
            scene.beginDirectAnimation(state_nibble_Plane, [visibleTog_state_nibble], 0, (267 + (iNibble * 64)) * frameRate / 2, false);    
      
            var planeWidth = 2;
            var planeHeight = 2;
            
            var DTWidth = planeWidth * 128;
            var DTHeight = planeHeight * 128;
            
            var i6 = 0;
            
            for (var x = 0; x < outHex.length; x++) {
            
              for (var y = 0; y < outHex[x].length; y++) {
              
                outHex[x][y] = aesSBox(inHex[x][y]);
                var letter = outHex[x][y];
                var letter2 = inHex[x][y];
                
                var nibbleDynTex = new BABYLON.DynamicTexture("nibbleDynTex", {width:DTWidth, height:DTHeight}, scene);
                var nibbleDynTex2 = new BABYLON.DynamicTexture("nibbleDynTex2", {width:DTWidth, height:DTHeight}, scene);
                var nibbleDynTex3 = new BABYLON.DynamicTexture("nibbleDynTex3", {width:DTWidth, height:DTHeight}, scene);
                var ctx = nibbleDynTex.getContext();
                
                // Font sized to fit the plane
                var font_type = "Arial";
                var size = 12;
                var text = "8D";
                ctx.font = size + "px " + font_type;
                var textWidth = ctx.measureText(text).width;
                
                var ratio = textWidth/size;
                
                var font_size = Math.floor(DTWidth / (ratio * 1));
                var font = font_size + "px " + font_type;
                
                var nibbleMat = new BABYLON.StandardMaterial("nibbleMat", scene);                    
                nibbleMat.diffuseTexture = nibbleDynTex;
                var nibbleMat2 = new BABYLON.StandardMaterial("nibbleMat2", scene);                    
                nibbleMat2.diffuseTexture = nibbleDynTex2;
                var nibbleMat3 = new BABYLON.StandardMaterial("nibbleMat3", scene);                    
                nibbleMat3.diffuseTexture = nibbleDynTex3;
                
                var nibblePlane = BABYLON.MeshBuilder.CreatePlane("nibblePlane", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                nibblePlane.material = nibbleMat;
                nibbleDynTex.drawText(letter, null, null, font, "blue", "yellow", true);
                var nibblePlane2 = BABYLON.MeshBuilder.CreatePlane("nibblePlane2", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                nibblePlane2.material = nibbleMat2;
                nibbleDynTex2.drawText(letter2, null, null, font, "blue", "white", true);
                var nibblePlane3 = BABYLON.MeshBuilder.CreatePlane("nibblePlane3", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                nibblePlane3.material = nibbleMat3;
                nibbleDynTex3.drawText(letter, null, null, font, "blue", "grey", true);
                
                nibblePlane.position = new BABYLON.Vector3(28, (x * -2.25) + -2.25, (y * -2.25) + 13);
                nibblePlane.rotation.y = Math.PI / 2;
                nibblePlane2.position = new BABYLON.Vector3(30, (x * -2.25) + -2.25, (y * -2.25) + 13);
                nibblePlane2.rotation.y = Math.PI / 2;
                nibblePlane3.position = new BABYLON.Vector3(28, (x * -2.25) + -2.25, (y * -2.25) + 13);
                nibblePlane3.rotation.y = Math.PI / 2;
                
                // Animation
                var visibleTog = new BABYLON.Animation("visibleTog", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                var visibleTog2 = new BABYLON.Animation("visibleTog2", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                var visibleTog3 = new BABYLON.Animation("visibleTog3", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                  
                var visFrames = [];
                
                visFrames.push({
                  frame: 0,
                  value: 0,
                });
                
                visFrames.push({
                  frame: ((202 + i6) + (iNibble * 64)) * frameRate / 2,
                  value: 0,
                });

                visFrames.push({
                  frame: ((202 + i6) + (iNibble * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames.push({
                  frame: ((203 + i6) + (iNibble * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames.push({
                  frame: ((203 + i6) + (iNibble * 64)) * frameRate / 2,
                  value: 0,
                });

                visFrames.push({
                  frame: (266 + (iNibble * 64)) * frameRate / 2,
                  value: 0,
                });
                
                visibleTog.setKeys(visFrames);
                
                scene.beginDirectAnimation(nibblePlane, [visibleTog], 0, (267 + (iNibble * 64)) * frameRate / 2, false);
                
                var visFrames2 = [];
                
                visFrames2.push({
                  frame: 0,
                  value: 0,
                });
                
                visFrames2.push({
                  frame: (202 + (iNibble * 64)) * frameRate / 2,
                  value: 0,
                });

                visFrames2.push({
                  frame: (202 + (iNibble * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames2.push({
                  frame: (266 + (iNibble * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames2.push({
                  frame: (266 + (iNibble * 64)) * frameRate / 2,
                  value: 0,
                });
                
                visibleTog2.setKeys(visFrames2);
                
                scene.beginDirectAnimation(nibblePlane2, [visibleTog2], 0, (267 + (iNibble * 64)) * frameRate / 2, false);
                
                var visFrames3 = [];
                
                visFrames3.push({
                  frame: 0,
                  value: 0,
                });
                
                visFrames3.push({
                  frame: ((203 + i6) + (iNibble * 64)) * frameRate / 2,
                  value: 0,
                });

                visFrames3.push({
                  frame: ((203 + i6) + (iNibble * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames3.push({
                  frame: (266 + (iNibble * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames3.push({
                  frame: (266 + (iNibble * 64)) * frameRate / 2,
                  value: 0,
                });
                
                visibleTog3.setKeys(visFrames3);
                
                scene.beginDirectAnimation(nibblePlane3, [visibleTog3], 0, (267 + (iNibble * 64)) * frameRate / 2, false);
                
                i6++;
                
              }
                            
            }
            
            iNibble++;
            
          }
                    
          return outHex;
            
        }
        
        /*
         * AESShiftRow
         *
         * This method performs the "Shift Row" operation
         *
         * Parameters:
         *  String [][] inStateHex: four by four matrix of pairs of hex digits
         *  numI: value of i
         *
         * Return value: shifted four by four matrix of pairs of hex digits
         */
        function AESShiftRow(inStateHex) {
        
          if (iShift < 10) {
          
            var row = 4, col = 4; 
            var outHex = Array(row).fill().map(() => Array(col));
            
            const frameRate = 10;
      
            //Set font
            var font_size_shift = 48;
            var font_state_shift = "bold " + font_size_shift + "px Arial";
            
            var planeHeight_state_shift = 2;
                    
            //Set height for dynamic texture
            var DTHeight_state_shift = 1.5 * font_size_shift; //or set as wished
            
            //Calcultae ratio
            var ratio_shift = planeHeight_state_shift/DTHeight_state_shift;
            
            //Use a temporay dynamic texture to calculate the length of the text on the dynamic texture canvas
            var temp = new BABYLON.DynamicTexture("DynamicTexture", 64, scene);
            var tmpctx = temp.getContext();
            tmpctx.font = font_state_shift;
            var DTWidth_state_shift = tmpctx.measureText("AESShiftRow()").width + 8;
            
            //Calculate width the plane has to be 
            var planeWidth_state_shift = DTWidth_state_shift * ratio_shift;
            
            // Dynamic texture setup
            var state_shift_PlaneDynTex = new BABYLON.DynamicTexture("state_shift_PlaneDynTex", {width:DTWidth_state_shift, height:DTHeight_state_shift}, scene);
            
            var state_shift_PlainMat = new BABYLON.StandardMaterial("state_shift_PlainMat", scene);
            state_shift_PlainMat.diffuseTexture = state_shift_PlaneDynTex;
            state_shift_PlainMat.diffuseTexture.hasAlpha = true;
            state_shift_PlainMat.useAlphaFromDiffuseTexture = true;
            
            var state_shift_Plane = BABYLON.MeshBuilder.CreatePlane("state_shift_Plane", {height: planeHeight_state_shift, width: planeWidth_state_shift, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            state_shift_Plane.material = state_shift_PlainMat;
            state_shift_PlaneDynTex.drawText("AESShiftRow()", null, null, font_state_shift, "blue", "transparent", true);
                         
            state_shift_PlainMat.onBindObservable.add(() => {
              
              engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
              
            });
            
            state_shift_Plane.position = new BABYLON.Vector3(30, 0, -3);
            state_shift_Plane.rotation.y = Math.PI / 2;
            
            // Animation
            var visibleTog_state_shift = new BABYLON.Animation("visibleTog_state_shift", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
            
            var visFrames_state_shift = [];
        
            visFrames_state_shift.push({
              frame: 0,
              value: 0,
            });
            
            visFrames_state_shift.push({
              frame: (218 + (iShift * 64)) * frameRate / 2,
              value: 0,
            });

            visFrames_state_shift.push({
              frame: (218 + (iShift * 64)) * frameRate / 2,
              value: 1,
            });

            visFrames_state_shift.push({
              frame: (266 + (iShift * 64)) * frameRate / 2,
              value: 1,
            });

            visFrames_state_shift.push({
              frame: (266 + (iShift * 64)) * frameRate / 2,
              value: 0,
            });

            visibleTog_state_shift.setKeys(visFrames_state_shift);
            
            scene.beginDirectAnimation(state_shift_Plane, [visibleTog_state_shift], 0, (267 + (iShift * 64)) * frameRate / 2, false); 
            
            var planeWidth = 2;
            var planeHeight = 2;
            
            var DTWidth = planeWidth * 128;
            var DTHeight = planeHeight * 128;
            
            var num = 0;
            var num2 = 17;
            
            for (var i = 0; i < 4; i++) {
              
              for (var j = 0; j < 4; j++) {
                
                outHex[i][j] = inStateHex[(i + j) % 4][j];
                                
                // get the inHex value
                var letter = outHex[i][j];
                var letter2 = inStateHex[i][j];
                
                var outHexDynTex = new BABYLON.DynamicTexture("outHexDynTex", {width:DTWidth, height:DTHeight}, scene);
                var outHexDynTex2 = new BABYLON.DynamicTexture("outHexDynTex2", {width:DTWidth, height:DTHeight}, scene);
                var ctx = outHexDynTex.getContext();
                
                // Font sized to fit the plane
                var font_type = "Arial";
                var size = 12;
                var text = "8D";
                ctx.font = size + "px " + font_type;
                var textWidth = ctx.measureText(text).width;
                
                var ratio = textWidth/size;
                
                var font_size = Math.floor(DTWidth / (ratio * 1));
                var font = font_size + "px " + font_type;
                
                var outHexMat = new BABYLON.StandardMaterial("outHexMat", scene);                    
                outHexMat.diffuseTexture = outHexDynTex;
                var outHexMat2 = new BABYLON.StandardMaterial("outHexMat2", scene);                    
                outHexMat2.diffuseTexture = outHexDynTex2;
                
                var outHexPlane = BABYLON.MeshBuilder.CreatePlane("outHexPlane", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                outHexPlane.material = outHexMat;
                var outHexPlane2 = BABYLON.MeshBuilder.CreatePlane("outHexPlane2", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                outHexPlane2.material = outHexMat2;
                
                if (num == 0 || num == 4 || num == 8 || num == 12) {
                
                  outHexDynTex.drawText(letter, null, null, font, "blue", "white", true);
                  
                } else if (num == 1 || num == 2 || num == 3 || num == 5 || num == 6 || num == 9) {
                
                  outHexDynTex.drawText(letter, null, null, font, "blue", "grey", true);
                
                } else {
                
                  outHexDynTex.drawText(letter, null, null, font, "blue", "yellow", true);
                  
                }
                
                outHexDynTex2.drawText(letter2, null, null, font, "blue", "white", true);
                
                outHexPlane.position = new BABYLON.Vector3(28, (i * -2.25) + -2.25, (j * -2.25) + 1);
                outHexPlane.rotation.y = Math.PI / 2;
                outHexPlane2.position = new BABYLON.Vector3(30, (i * -2.25) + -2.25, (j * -2.25) + 1);
                outHexPlane2.rotation.y = Math.PI / 2;
                
                // Animation
                var visibleTog = new BABYLON.Animation("visibleTog", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                var visibleTog2 = new BABYLON.Animation("visibleTog2", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                  
                var visFrames = [];
                
                visFrames.push({
                  frame: 0,
                  value: 0,
                });
                
                visFrames.push({
                  frame: (num + ((218 + (iShift * 64)))) * frameRate / 2,
                  value: 0,
                });
                
                visFrames.push({
                  frame: (num + ((218 + (iShift * 64)))) * frameRate / 2,
                  value: 1,
                });

                visFrames.push({
                  frame: (266 + (iShift * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames.push({
                  frame: (266 + (iShift * 64)) * frameRate / 2,
                  value: 0,
                });

                visibleTog.setKeys(visFrames);
                
                scene.beginDirectAnimation(outHexPlane, [visibleTog], 0, (267 + (iShift * 64)) * frameRate / 2, false);
                
                var visFrames2 = [];
                
                visFrames2.push({
                  frame: 0,
                  value: 0,
                });
                
                visFrames2.push({
                  frame: (218 + (iShift * 64)) * frameRate / 2,
                  value: 0,
                });

                visFrames2.push({
                  frame: (218 + (iShift * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames2.push({
                  frame: (266 + (iShift * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames2.push({
                  frame: (266 + (iShift * 64)) * frameRate / 2,
                  value: 0,
                });
                
                visibleTog2.setKeys(visFrames2);
                
                scene.beginDirectAnimation(outHexPlane2, [visibleTog2], 0, (267 + (iShift * 64)) * frameRate / 2, false);
                
                num++;
                num2--;
                
              }
                
            }
            
            iShift++;
            
          }
          
          return outHex;
                      
        }
        
        /*
         * GMul
         *
         * This method performs the Galois Field multiplication
         * for the AESMixColumn function.
         *
         * Parameters:
         *  String a: string
         *  String b: string
         *
         * Return value: string
         */
        function GMul(a, b) {
          
          var p = 0;
          var ai = parseInt(a, 16);
          var bi = parseInt(b, 16);
          
          for (var i = 0; i < 8; i++) {
            
            if ((bi & 0x01) == 1) {
              
              p = (p ^ ai) & 0xFF;
                
            }

            var hi_bit_set = ((ai & 0x80) == 0x80);
            
            ai <<= 1;
            
            if (hi_bit_set) {
              
              ai = (ai ^ 0x1B) & 0xFF;
                
            }
            
            bi = (bi >> 1) & 0x7F;
              
          }

          return p.toString(16).toUpperCase();
            
        }
        
        /*
         * toMatrix
         *
         * This method converts a string to a four by four matrix.
         *
         * Parameters:
         *  String value: string
         *
         * Return value: four by four matrix
         */
        function toMatrix(value) {
          
          var row = 4, col = 4; 
          var ret = Array(row).fill().map(() => Array(col));
          
          for (var i = 0; i < 4; i++) {
            
            for (var j = 0; j < 4; j++) {
              
              ret[i][j] = value.substring((i*4 + j) * 2, (i*4 + j + 1) * 2);
                
            }
              
          }
          
          return ret;
            
        }
        
        /*
         * fromMatrix
         *
         * This method converts a four by four matrix to a string.
         *
         * Parameters:
         *  String[][] value: four by four matrix
         *
         * Return value: string
         */
        function fromMatrix(value) {
          
          var out = "";
          
          for (var i = 0; i < 4; i++) {
            
            for (var j = 0; j < 4; j++) {
              
              out += value[i][j];
                
            }
              
          }
          
          return out;
            
        }
        
        /*
         * AESMixColumn
         *
         * This method performs the "Mix Column" operation.
         *
         * Parameters:
         *  String[][] inStateHex: four by four matrix of pairs of hex digits
         *
         * Return value: four by four matrix of pairs of hex digits
         */
        function AESMixColumn(inStateHex) {
          
          if (iMix < 9) {
          
            var row = 4, col = 4; 
            var out = Array(row).fill().map(() => Array(col));
            
            const frameRate = 10;
      
            //Set font
            var font_size_mix = 48;
            var font_state_mix = "bold " + font_size_mix + "px Arial";
            
            var planeHeight_state_mix = 2;
                    
            //Set height for dynamic texture
            var DTHeight_state_mix = 1.5 * font_size_mix; //or set as wished
            
            //Calcultae ratio
            var ratio_mix = planeHeight_state_mix/DTHeight_state_mix;
            
            //Use a temporay dynamic texture to calculate the length of the text on the dynamic texture canvas
            var temp = new BABYLON.DynamicTexture("DynamicTexture", 64, scene);
            var tmpctx = temp.getContext();
            tmpctx.font = font_state_mix;
            var DTWidth_state_mix = tmpctx.measureText("AESMixColumn()").width + 8;
            
            //Calculate width the plane has to be 
            var planeWidth_state_mix = DTWidth_state_mix * ratio_mix;
            
            // Dynamic texture setup
            var state_mix_PlaneDynTex = new BABYLON.DynamicTexture("state_mix_PlaneDynTex", {width:DTWidth_state_mix, height:DTHeight_state_mix}, scene);
            
            var state_mix_PlainMat = new BABYLON.StandardMaterial("state_mix_PlainMat", scene);
            state_mix_PlainMat.diffuseTexture = state_mix_PlaneDynTex;
            state_mix_PlainMat.diffuseTexture.hasAlpha = true;
            state_mix_PlainMat.useAlphaFromDiffuseTexture = true;
            
            var state_mix_Plane = BABYLON.MeshBuilder.CreatePlane("state_mix_Plane", {height: planeHeight_state_mix, width: planeWidth_state_mix, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            state_mix_Plane.material = state_mix_PlainMat;
            state_mix_PlaneDynTex.drawText("AESMixColumn()", null, null, font_state_mix, "blue", "transparent", true);
                         
            state_mix_PlainMat.onBindObservable.add(() => {
              
              engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
              
            });
            
            state_mix_Plane.position = new BABYLON.Vector3(30, 0, -16);
            state_mix_Plane.rotation.y = Math.PI / 2;
            
            // Animation
            var visibleTog_state_mix = new BABYLON.Animation("visibleTog_state_mix", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
            
            var visFrames_state_mix = [];
        
            visFrames_state_mix.push({
              frame: 0,
              value: 0,
            });
            
            visFrames_state_mix.push({
              frame: (234 + (iMix * 64)) * frameRate / 2,
              value: 0,
            });

            visFrames_state_mix.push({
              frame: (234 + (iMix * 64)) * frameRate / 2,
              value: 1,
            });

            visFrames_state_mix.push({
              frame: (266 + (iMix * 64)) * frameRate / 2,
              value: 1,
            });

            visFrames_state_mix.push({
              frame: (266 + (iMix * 64)) * frameRate / 2,
              value: 0,
            });

            visibleTog_state_mix.setKeys(visFrames_state_mix);
            
            scene.beginDirectAnimation(state_mix_Plane, [visibleTog_state_mix], 0, (267 + (iMix * 64)) * frameRate / 2, false); 
                        
            var planeWidth = 2;
            var planeHeight = 2;
            
            var DTWidth = planeWidth * 128;
            var DTHeight = planeHeight * 128;
            
            for (var x = 0; x < 4; x++) {
              
              for (var y = 0; y < 4; y++) {
                
                var letter = inStateHex[x][y];
                var letter2 = out[x][y];
                
                var outHexDynTex = new BABYLON.DynamicTexture("outHexDynTex", {width:DTWidth, height:DTHeight}, scene);
                var ctx = outHexDynTex.getContext();
                
                // Font sized to fit the plane
                var font_type = "Arial";
                var size = 12;
                var text = "8D";
                ctx.font = size + "px " + font_type;
                var textWidth = ctx.measureText(text).width;
                
                var ratio = textWidth/size;
                
                var font_size = Math.floor(DTWidth / (ratio * 1));
                var font = font_size + "px " + font_type;
                
                var outHexMat = new BABYLON.StandardMaterial("outHexMat", scene);                    
                outHexMat.diffuseTexture = outHexDynTex;
                
                var outHexPlane = BABYLON.MeshBuilder.CreatePlane("outHexPlane", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                outHexPlane.material = outHexMat;
                outHexDynTex.drawText(letter, null, null, font, "blue", "white", true);
                
                outHexPlane.position = new BABYLON.Vector3(30, (x * -2.25) + -2.25, (y * -2.25) + -12);
                outHexPlane.rotation.y = Math.PI / 2;
                
                // Animation
                var visibleTog = new BABYLON.Animation("visibleTog", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                  
                var visFrames = [];
                                
                visFrames.push({
                  frame: 0,
                  value: 0,
                });
                
                visFrames.push({
                  frame: (234 + (iMix * 64)) * frameRate / 2,
                  value: 0,
                });

                visFrames.push({
                  frame: (234 + (iMix * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames.push({
                  frame: (266 + (iMix * 64)) * frameRate / 2,
                  value: 1,
                });

                visFrames.push({
                  frame: (266 + (iMix * 64)) * frameRate / 2,
                  value: 0,
                });
                                
                visibleTog.setKeys(visFrames);
                
                scene.beginDirectAnimation(outHexPlane, [visibleTog], 0, (267 + (iMix * 64)) * frameRate / 2, false);
                             
              }
                
            }
                                   
            for (var i = 0; i < 4; i++) {
              
              out[i][0] = XorHex(GMul("02", inStateHex[i][0]), GMul("03", inStateHex[i][1]), inStateHex[i][2], inStateHex[i][3]);
              out[i][1] = XorHex(inStateHex[i][0], GMul("02", inStateHex[i][1]), GMul("03", inStateHex[i][2]), inStateHex[i][3]);
              out[i][2] = XorHex(inStateHex[i][0], inStateHex[i][1], GMul("02", inStateHex[i][2]), GMul("03", inStateHex[i][3]));
              out[i][3] = XorHex(GMul("03", inStateHex[i][0]), inStateHex[i][1], inStateHex[i][2], GMul("02", inStateHex[i][3]));
              
              var oNum = out[i][0];
              var oNum2 = out[i][1];
              var oNum3 = out[i][2];
              var oNum4 = out[i][3];
              
              var mixDynTex = new BABYLON.DynamicTexture("mixDynTex", {width:DTWidth, height:DTHeight}, scene);
              var mixDynTex2 = new BABYLON.DynamicTexture("mixDynTex2", {width:DTWidth, height:DTHeight}, scene);
              var mixDynTex3 = new BABYLON.DynamicTexture("mixDynTex3", {width:DTWidth, height:DTHeight}, scene);
              var mixDynTex4 = new BABYLON.DynamicTexture("mixDynTex4", {width:DTWidth, height:DTHeight}, scene);
              var mixDynTex5 = new BABYLON.DynamicTexture("mixDynTex5", {width:DTWidth, height:DTHeight}, scene);
              var mixDynTex6 = new BABYLON.DynamicTexture("mixDynTex6", {width:DTWidth, height:DTHeight}, scene);
              var mixDynTex7 = new BABYLON.DynamicTexture("mixDynTex7", {width:DTWidth, height:DTHeight}, scene);
              var mixDynTex8 = new BABYLON.DynamicTexture("mixDynTex8", {width:DTWidth, height:DTHeight}, scene);
              var ctx = mixDynTex.getContext();
              
              // Font sized to fit the plane
              var font_type = "Arial";
              var size = 12;
              var text = "8D";
              ctx.font = size + "px " + font_type;
              var textWidth = ctx.measureText(text).width;
              
              var ratio = textWidth/size;
              
              var font_size = Math.floor(DTWidth / (ratio * 1));
              var font = font_size + "px " + font_type;
              
              var mixMat = new BABYLON.StandardMaterial("mixMat", scene);                    
              mixMat.diffuseTexture = mixDynTex;
              var mixMat2 = new BABYLON.StandardMaterial("mixMat2", scene);                    
              mixMat2.diffuseTexture = mixDynTex2;
              var mixMat3 = new BABYLON.StandardMaterial("mixMat3", scene);                    
              mixMat3.diffuseTexture = mixDynTex3;
              var mixMat4 = new BABYLON.StandardMaterial("mixMat4", scene);                    
              mixMat4.diffuseTexture = mixDynTex4;
              var mixMat5 = new BABYLON.StandardMaterial("mixMat5", scene);                    
              mixMat5.diffuseTexture = mixDynTex5;
              var mixMat6 = new BABYLON.StandardMaterial("mixMat6", scene);                    
              mixMat6.diffuseTexture = mixDynTex6;
              var mixMat7 = new BABYLON.StandardMaterial("mixMat7", scene);                    
              mixMat7.diffuseTexture = mixDynTex7;
              var mixMat8 = new BABYLON.StandardMaterial("mixMat8", scene);                    
              mixMat8.diffuseTexture = mixDynTex8;
              
              var mixPlane = BABYLON.MeshBuilder.CreatePlane("mixPlane", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
              mixPlane.material = mixMat;
              mixDynTex.drawText(oNum, null, null, font, "blue", "yellow", true);
              var mixPlane2 = BABYLON.MeshBuilder.CreatePlane("mixPlane2", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
              mixPlane2.material = mixMat2;
              mixDynTex2.drawText(oNum2, null, null, font, "blue", "yellow", true);
              var mixPlane3 = BABYLON.MeshBuilder.CreatePlane("mixPlane3", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
              mixPlane3.material = mixMat3;
              mixDynTex3.drawText(oNum3, null, null, font, "blue", "yellow", true);
              var mixPlane4 = BABYLON.MeshBuilder.CreatePlane("mixPlane4", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
              mixPlane4.material = mixMat4;
              mixDynTex4.drawText(oNum4, null, null, font, "blue", "yellow", true);             
              
              var mixPlane5 = BABYLON.MeshBuilder.CreatePlane("mixPlane5", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
              mixPlane5.material = mixMat5;
              mixDynTex5.drawText(oNum, null, null, font, "blue", "grey", true);
              var mixPlane6 = BABYLON.MeshBuilder.CreatePlane("mixPlane6", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
              mixPlane6.material = mixMat6;
              mixDynTex6.drawText(oNum2, null, null, font, "blue", "grey", true);
              var mixPlane7 = BABYLON.MeshBuilder.CreatePlane("mixPlane7", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
              mixPlane7.material = mixMat7;
              mixDynTex7.drawText(oNum3, null, null, font, "blue", "grey", true);
              var mixPlane8 = BABYLON.MeshBuilder.CreatePlane("mixPlane8", {height: planeHeight, width: planeWidth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
              mixPlane8.material = mixMat8;
              mixDynTex8.drawText(oNum4, null, null, font, "blue", "grey", true);
              
              mixPlane.position = new BABYLON.Vector3(28, (i * -2.25) + -2.25, -12);
              mixPlane.rotation.y = Math.PI / 2;
              mixPlane2.position = new BABYLON.Vector3(28, (i * -2.25) + -2.25, -14.25);
              mixPlane2.rotation.y = Math.PI / 2;
              mixPlane3.position = new BABYLON.Vector3(28, (i * -2.25) + -2.25, -16.5);
              mixPlane3.rotation.y = Math.PI / 2;
              mixPlane4.position = new BABYLON.Vector3(28, (i * -2.25) + -2.25, -18.75);
              mixPlane4.rotation.y = Math.PI / 2;
              mixPlane5.position = new BABYLON.Vector3(28, (i * -2.25) + -2.25, -12);
              mixPlane5.rotation.y = Math.PI / 2;
              mixPlane6.position = new BABYLON.Vector3(28, (i * -2.25) + -2.25, -14.25);
              mixPlane6.rotation.y = Math.PI / 2;
              mixPlane7.position = new BABYLON.Vector3(28, (i * -2.25) + -2.25, -16.5);
              mixPlane7.rotation.y = Math.PI / 2;
              mixPlane8.position = new BABYLON.Vector3(28, (i * -2.25) + -2.25, -18.75);
              mixPlane8.rotation.y = Math.PI / 2;
              
              // Animation
              var mixVisibleTog = new BABYLON.Animation("mixVisibleTog", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
              var mixVisibleTog2 = new BABYLON.Animation("mixVisibleTog2", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
              var mixVisibleTog3 = new BABYLON.Animation("mixVisibleTog3", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
              var mixVisibleTog4 = new BABYLON.Animation("mixVisibleTog4", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
              
              var mixVisibleTog5 = new BABYLON.Animation("mixVisibleTog5", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
              var mixVisibleTog6 = new BABYLON.Animation("mixVisibleTog6", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
              var mixVisibleTog7 = new BABYLON.Animation("mixVisibleTog7", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
              var mixVisibleTog8 = new BABYLON.Animation("mixVisibleTog8", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                
              var mixVisFrames = [];
                              
              mixVisFrames.push({
                frame: 0,
                value: 0,
              });
              
              mixVisFrames.push({
                frame: (234 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });

              mixVisFrames.push({
                frame: (234 + (iMix * 64)) * frameRate / 2,
                value: 1,
              });
              
              mixVisFrames.push({
                frame: (235 + (iMix * 64)) * frameRate / 2,
                value: 1,
              });

              mixVisFrames.push({
                frame: (235 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });

              mixVisFrames.push({
                frame: (266 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });
              
              mixVisibleTog.setKeys(mixVisFrames);
                
              scene.beginDirectAnimation(mixPlane, [mixVisibleTog], 0, (267 + (iMix * 64)) * frameRate / 2, false);
              
              var mixVisFrames2 = [];
                              
              mixVisFrames2.push({
                frame: 0,
                value: 0,
              });
              
              mixVisFrames2.push({
                frame: (238 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });

              mixVisFrames2.push({
                frame: (238 + (iMix * 64)) * frameRate / 2,
                value: 1,
              });
              
              mixVisFrames2.push({
                frame: (239 + (iMix * 64)) * frameRate / 2,
                value: 1,
              });

              mixVisFrames2.push({
                frame: (239 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });

              mixVisFrames2.push({
                frame: (266 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });
              
              mixVisibleTog2.setKeys(mixVisFrames2);
                
              scene.beginDirectAnimation(mixPlane2, [mixVisibleTog2], 0, (267 + (iMix * 64)) * frameRate / 2, false);
              
              var mixVisFrames3 = [];
                              
              mixVisFrames3.push({
                frame: 0,
                value: 0,
              });
              
              mixVisFrames3.push({
                frame: (242 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });

              mixVisFrames3.push({
                frame: (242 + (iMix * 64)) * frameRate / 2,
                value: 1,
              });
              
              mixVisFrames3.push({
                frame: (243 + (iMix * 64)) * frameRate / 2,
                value: 1,
              });

              mixVisFrames3.push({
                frame: (243 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });

              mixVisFrames3.push({
                frame: (266 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });
              
              mixVisibleTog3.setKeys(mixVisFrames3);
                
              scene.beginDirectAnimation(mixPlane3, [mixVisibleTog3], 0, (267 + (iMix * 64)) * frameRate / 2, false);
              
              var mixVisFrames4 = [];
                              
              mixVisFrames4.push({
                frame: 0,
                value: 0,
              });
              
              mixVisFrames4.push({
                frame: (246 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });

              mixVisFrames4.push({
                frame: (246 + (iMix * 64)) * frameRate / 2,
                value: 1,
              });
              
              mixVisFrames4.push({
                frame: (247 + (iMix * 64)) * frameRate / 2,
                value: 1,
              });

              mixVisFrames4.push({
                frame: (247 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });

              mixVisFrames4.push({
                frame: (266 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });
              
              mixVisibleTog4.setKeys(mixVisFrames4);
                
              scene.beginDirectAnimation(mixPlane4, [mixVisibleTog4], 0, (267 + (iMix * 64)) * frameRate / 2, false);
              
              var mixVisFrames5 = [];
                              
              mixVisFrames5.push({
                frame: 0,
                value: 0,
              });
              
              mixVisFrames5.push({
                frame: (235 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });

              mixVisFrames5.push({
                frame: (235 + (iMix * 64)) * frameRate / 2,
                value: 1,
              });

              mixVisFrames5.push({
                frame: (266 + (iMix * 64)) * frameRate / 2,
                value: 1,
              });

              mixVisFrames5.push({
                frame: (266 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });
              
              mixVisibleTog5.setKeys(mixVisFrames5);
                
              scene.beginDirectAnimation(mixPlane5, [mixVisibleTog5], 0, (267 + (iMix * 64)) * frameRate / 2, false);
              
              var mixVisFrames6 = [];
                              
              mixVisFrames6.push({
                frame: 0,
                value: 0,
              });
              
              mixVisFrames6.push({
                frame: (239 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });

              mixVisFrames6.push({
                frame: (239 + (iMix * 64)) * frameRate / 2,
                value: 1,
              });
              
              mixVisFrames6.push({
                frame: (266 + (iMix * 64)) * frameRate / 2,
                value: 1,
              });

              mixVisFrames6.push({
                frame: (266 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });
              
              mixVisibleTog6.setKeys(mixVisFrames6);
                
              scene.beginDirectAnimation(mixPlane6, [mixVisibleTog6], 0, (267 + (iMix * 64)) * frameRate / 2, false);
              
              var mixVisFrames7 = [];
                              
              mixVisFrames7.push({
                frame: 0,
                value: 0,
              });
              
              mixVisFrames7.push({
                frame: (243 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });

              mixVisFrames7.push({
                frame: (243 + (iMix * 64)) * frameRate / 2,
                value: 1,
              });
              
              mixVisFrames7.push({
                frame: (266 + (iMix * 64)) * frameRate / 2,
                value: 1,
              });

              mixVisFrames7.push({
                frame: (266 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });
              
              mixVisibleTog7.setKeys(mixVisFrames7);
                
              scene.beginDirectAnimation(mixPlane7, [mixVisibleTog7], 0, (267 + (iMix * 64)) * frameRate / 2, false);
              
              var mixVisFrames8 = [];
                              
              mixVisFrames8.push({
                frame: 0,
                value: 0,
              });
              
              mixVisFrames8.push({
                frame: (247 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });

              mixVisFrames8.push({
                frame: (247 + (iMix * 64)) * frameRate / 2,
                value: 1,
              });
              
              mixVisFrames8.push({
                frame: (266 + (iMix * 64)) * frameRate / 2,
                value: 1,
              });

              mixVisFrames8.push({
                frame: (266 + (iMix * 64)) * frameRate / 2,
                value: 0,
              });
              
              mixVisibleTog8.setKeys(mixVisFrames8);
                
              scene.beginDirectAnimation(mixPlane8, [mixVisibleTog8], 0, (267 + (iMix * 64)) * frameRate / 2, false);
              
            }
            
            iMix++;
                        
          }

          return out;
            
        }
        
        /*
         * AES
         *
         * This method performs AES encryption.
         *
         * Parameters:
         *  String pTextHex: plaintext block
         *  String keyHex: system key
         *
         * Return value: ciphertext (all in upper case)
         */
        function AES(pTextHex, keyHex) {
          
          var keyExp = [];
          keyExp = aesRoundKeys(keyHex);
          
          var row = 4, col = 4;
          var state = Array(row).fill().map(() => Array(col));
          state = toMatrix(pTextHex);
          
          const frameRate = 10;
                   
          //Set font
          var font_size_state = 48;
          var font_state = "bold " + font_size_state + "px Arial";
          
          var planeHeight_state = 2;
                  
          //Set height for dynamic texture
          var DTHeight_state = 1.5 * font_size_state; //or set as wished
          
          //Calcultae ratio
          var ratio = planeHeight_state/DTHeight_state;
          
          //Use a temporay dynamic texture to calculate the length of the text on the dynamic texture canvas
          var temp = new BABYLON.DynamicTexture("DynamicTexture", 64, scene);
          var tmpctx = temp.getContext();
          tmpctx.font = font_state;
          var DTWidth_state = tmpctx.measureText("state = toMatrix(pTextHex)").width + 8;
          
          //Calculate width the plane has to be 
          var planeWidth_state = DTWidth_state * ratio;
          
          // Dynamic texture setup
          var statePlaneDynTex = new BABYLON.DynamicTexture("statePlaneDynTex", {width:DTWidth_state, height:DTHeight_state}, scene);
          
          var statePlainMat = new BABYLON.StandardMaterial("statePlainMat", scene);
          statePlainMat.diffuseTexture = statePlaneDynTex;
          statePlainMat.diffuseTexture.hasAlpha = true;
          statePlainMat.useAlphaFromDiffuseTexture = true;
          
          var statePlane = BABYLON.MeshBuilder.CreatePlane("statePlane", {height: planeHeight_state, width: planeWidth_state, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
          statePlane.material = statePlainMat;
          statePlaneDynTex.drawText("state = toMatrix(pTextHex)", null, null, font_state, "blue", "transparent", true);
                       
          statePlainMat.onBindObservable.add(() => {
            
            engine.alphaState.setAlphaBlendFunctionParameters(1, 0x0303 /* ONE MINUS SRC ALPHA */, 1, 0x0303 /* ONE MINUS SRC ALPHA */);
            
          });

          statePlane.position = new BABYLON.Vector3(30, 0, 0);
          statePlane.rotation.y = Math.PI / 2;
          
          // Animation
          var visibleTog_state = new BABYLON.Animation("visibleTog_state", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
          
          var visFrames_state = [];
      
          visFrames_state.push({
            frame: 0,
            value: 0,
          });
          
          visFrames_state.push({
            frame: 180 * frameRate / 2,
            value: 0,
          });

          visFrames_state.push({
            frame: 180 * frameRate / 2,
            value: 1,
          });

          visFrames_state.push({
            frame: 184 * frameRate / 2,
            value: 1,
          });

          visFrames_state.push({
            frame: 184 * frameRate / 2,
            value: 0,
          });

          visibleTog_state.setKeys(visFrames_state);
          
          scene.beginDirectAnimation(statePlane, [visibleTog_state], 0, 185 * frameRate / 2, false);
          
          //  initial state Matrix
          var planeWidth_sMatrix = 2;
          var planeHeight_sMatrix = 2;
          
          var DTWidth_sMatrix = planeWidth_sMatrix * 128;
          var DTHeight_sMatrix = planeHeight_sMatrix * 128;
          
          for (var xM = 0; xM < state.length; xM++) {
          
            for (var yM = 0; yM < state[xM].length; yM++) {
              
              var dat_sMatrix = state[yM][xM];
                      
              var toMatrixDynTex = new BABYLON.DynamicTexture("toMatrixDynTex", {width:DTWidth_sMatrix, height:DTHeight_sMatrix}, scene);
              var ctx = toMatrixDynTex.getContext();
              
              // Font sized to fit the plane
              var font_type_sMatrix = "Arial";
              var size_sMatrix = 12;
              var text_sMatrix = "8D";
              ctx.font = size_sMatrix + "px " + font_type_sMatrix;
              var textWidth_sMatrix = ctx.measureText(text_sMatrix).width;
              
              var ratio_sMatrix = textWidth_sMatrix/size_sMatrix;
              
              var font_size_sMatrix = Math.floor(DTWidth_sMatrix / (ratio_sMatrix * 1));
              var font_sMatrix = font_size_sMatrix + "px " + font_type_sMatrix;
              
              var toMatrixMat = new BABYLON.StandardMaterial("toMatrixMat", scene);                    
              toMatrixMat.diffuseTexture = toMatrixDynTex;
              
              var toMatrixPlane = BABYLON.MeshBuilder.CreatePlane("toMatrixPlane", {height: planeHeight_sMatrix, width: planeWidth_sMatrix, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
              toMatrixPlane.material = toMatrixMat;
              toMatrixDynTex.drawText(dat_sMatrix, null, null, font_sMatrix, "blue", "white", true);
                                          
              toMatrixPlane.position = new BABYLON.Vector3(30, (yM * -2.25) + -2.25, (xM * -2.25) + 6);
              toMatrixPlane.rotation.y = Math.PI / 2;
              
              // Animation
              var visibleTog_sMatrix = new BABYLON.Animation("visibleTog_sMatrix", "visibility", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
              
              var visFrames_sMatrix = [];
          
              visFrames_sMatrix.push({
                frame: 0,
                value: 0,
              });
              
              visFrames_sMatrix.push({
                frame: 180 * frameRate / 2,
                value: 0,
              });

              visFrames_sMatrix.push({
                frame: 180 * frameRate / 2,
                value: 1,
              });

              visFrames_sMatrix.push({
                frame: 184 * frameRate / 2,
                value: 1,
              });

              visFrames_sMatrix.push({
                frame: 184 * frameRate / 2,
                value: 0,
              });

              visibleTog_sMatrix.setKeys(visFrames_sMatrix);
              
              scene.beginDirectAnimation(toMatrixPlane, [visibleTog_sMatrix], 0, 185 * frameRate / 2, false);
                            
            }
            
          }
          
          state = AESStateXOR(state, toMatrix(keyExp[0]));
          
          for (var i = 1; i < 10; i++) {
            
            state = AESNibbleSub(state);
            iSBox2++;
            state = AESShiftRow(state);            
            state = AESMixColumn(state);
            state = AESStateXOR(state, toMatrix(keyExp[i]));
                                      
          }

          state = AESNibbleSub(state);
          state = AESShiftRow(state);
          state = AESStateXOR(state, toMatrix(keyExp[keyExp.length - 1]));
          
          return fromMatrix(state);
                      
        }
        
        return scene;
        
      }
      
      const scene = createScene();

      engine.runRenderLoop(function () {
        
        scene.render();
        
      });

      window.addEventListener("resize", function () {
        
        engine.resize();
        
      });
        
    </script>
    
  </body>
</html>